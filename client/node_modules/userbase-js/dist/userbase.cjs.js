(function(e, a) { for(var i in a) e[i] = a[i]; }(exports, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 7);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = require("base64-arraybuffer");

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = require("@babel/runtime/helpers/defineProperty");

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = require("uuid/v4");

/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = require("lz-string");

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = require("diffie-hellman");

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = require("scrypt-js");

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = require("sorted-array");

/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: external "@babel/runtime/helpers/defineProperty"
var defineProperty_ = __webpack_require__(1);
var defineProperty_default = /*#__PURE__*/__webpack_require__.n(defineProperty_);

// EXTERNAL MODULE: external "base64-arraybuffer"
var external_base64_arraybuffer_ = __webpack_require__(0);
var external_base64_arraybuffer_default = /*#__PURE__*/__webpack_require__.n(external_base64_arraybuffer_);

// CONCATENATED MODULE: ./src/statusCodes.js
/* harmony default export */ var statusCodes = ({
  'Success': 200,
  'Bad Request': 400,
  'Unauthorized': 401,
  'Payment Required': 402,
  'Forbidden': 403,
  'Not Found': 404,
  'Conflict': 409,
  'Too Many Requests': 429,
  'Internal Server Error': 500,
  'Service Unavailable': 503,
  'Gateway Timeout': 504,
  // WebSocket close event codes
  'Service Restart': 1012,
  // Custom ws close event codes
  'No Pong Received': 3000,
  'Client Already Connected': 3001
});
// CONCATENATED MODULE: ./src/errors/auth.js


class auth_UsernameAlreadyExists extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'UsernameAlreadyExists';
    this.message = 'Username already exists.';
    this.status = statusCodes['Conflict'];
  }

}

class auth_UsernameMissing extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'UsernameMissing';
    this.message = 'Username missing.';
    this.status = statusCodes['Bad Request'];
  }

}

class auth_UsernameCannotBeBlank extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'UsernameCannotBeBlank';
    this.message = 'Username cannot be blank.';
    this.status = statusCodes['Bad Request'];
  }

}

class auth_UsernameTooLong extends Error {
  constructor(maxLen, ...params) {
    super(maxLen, ...params);
    this.name = 'UsernameTooLong';
    this.message = "Username too long. Must be a max of ".concat(maxLen, " characters.");
    this.status = statusCodes['Bad Request'];
  }

}

class auth_UsernameMustBeString extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'UsernameMustBeString';
    this.message = 'Username must be a string.';
    this.status = statusCodes['Bad Request'];
  }

}

class auth_PasswordMissing extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'PasswordMissing';
    this.message = 'Password missing.';
    this.status = statusCodes['Bad Request'];
  }

}

class auth_PasswordCannotBeBlank extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'PasswordCannotBeBlank';
    this.message = 'Password cannot be blank.';
    this.status = statusCodes['Bad Request'];
  }

}

class auth_PasswordTooShort extends Error {
  constructor(minLen, ...params) {
    super(minLen, ...params);
    this.name = 'PasswordTooShort';
    this.message = "Password too short. Must be a minimum of ".concat(minLen, " characters.");
    this.status = statusCodes['Bad Request'];
  }

}

class auth_PasswordTooLong extends Error {
  constructor(maxLen, ...params) {
    super(maxLen, ...params);
    this.name = 'PasswordTooLong';
    this.message = "Password too long. Must be a max of ".concat(maxLen, " characters.");
    this.status = statusCodes['Bad Request'];
  }

}

class auth_PasswordMustBeString extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'PasswordMustBeString';
    this.message = 'Password must be a string.';
    this.status = statusCodes['Bad Request'];
  }

}

class auth_PasswordAttemptLimitExceeded extends Error {
  constructor(delay, ...params) {
    super(delay, ...params);
    this.name = 'PasswordAttemptLimitExceeded';
    this.message = "Password attempt limit exceeded. Must wait ".concat(delay, " to attempt to use password again.");
    this.status = statusCodes['Unauthorized'];
  }

}

class auth_UsernameOrPasswordMismatch extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'UsernameOrPasswordMismatch';
    this.message = 'Username or password mismatch.';
    this.status = statusCodes['Unauthorized'];
  }

}

class auth_UserAlreadySignedIn extends Error {
  constructor(username, ...params) {
    super(...params);
    this.name = 'UserAlreadySignedIn';
    this.message = 'Already signed in.';
    this.status = statusCodes['Bad Request'];
    this.username = username;
  }

}

class auth_UserPendingDeletion extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'UserPendingDeletion';
    this.message = 'User is pending deletion.';
    this.status = statusCodes['Forbidden'];
  }

}

class auth_AppIdNotValid extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'AppIdNotValid';
    this.message = 'App ID not valid.';
    this.status = statusCodes['Unauthorized'];
  }

}

class auth_UserNotSignedIn extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'UserNotSignedIn';
    this.message = 'Not signed in.';
    this.status = statusCodes['Bad Request'];
  }

}

class auth_UserNotFound extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'UserNotFound';
    this.message = 'User not found.';
    this.status = statusCodes['Not Found'];
  }

}

class auth_UserEmailNotFound extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'UserEmailNotFound';
    this.message = 'User does not have an email saved.';
    this.status = statusCodes['Not Found'];
  }

}

class auth_EmailNotValid extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'EmailNotValid';
    this.message = 'Email not valid.';
    this.status = statusCodes['Bad Request'];
  }

}

class auth_ProfileMustBeObject extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'ProfileMustBeObject';
    this.message = 'Profile must be a flat JSON object.';
    this.status = statusCodes['Bad Request'];
  }

}

class auth_ProfileCannotBeEmpty extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'ProfileCannotBeEmpty';
    this.message = 'Profile cannot be empty.';
    this.status = statusCodes['Bad Request'];
  }

}

class auth_ProfileHasTooManyKeys extends Error {
  constructor(maxKeys, ...params) {
    super(maxKeys, ...params);
    this.name = 'ProfileHasTooManyKeys';
    this.message = "Profile has too many keys. Must have a max of ".concat(maxKeys, " keys.");
    this.status = statusCodes['Bad Request'];
  }

}

class auth_ProfileKeyTooLong extends Error {
  constructor(maxLen, key, ...params) {
    super(maxLen, key, ...params);
    this.name = 'ProfileKeyTooLong';
    this.message = "Profile key too long. Must be a max of ".concat(maxLen, " characters.");
    this.status = statusCodes['Bad Request'];
    this.key = key;
  }

}

class auth_ProfileValueMustBeString extends Error {
  constructor(key, value, ...params) {
    super(key, value, ...params);
    this.name = 'ProfileValueMustBeString';
    this.message = 'Profile value must be a string.';
    this.status = statusCodes['Bad Request'];
    this.key = key;
    this.value = value;
  }

}

class auth_ProfileValueCannotBeBlank extends Error {
  constructor(key, ...params) {
    super(key, ...params);
    this.name = 'ProfileValueCannotBeBlank';
    this.message = 'Profile value cannot be blank.';
    this.status = statusCodes['Bad Request'];
    this.key = key;
  }

}

class auth_ProfileValueTooLong extends Error {
  constructor(maxLen, key, value, ...params) {
    super(maxLen, key, value, ...params);
    this.name = 'ProfileValueTooLong';
    this.message = "Profile value too long. Must be a max of ".concat(maxLen, " characters.");
    this.status = statusCodes['Bad Request'];
    this.key = key;
    this.value = value;
  }

}

class auth_RememberMeValueNotValid extends Error {
  constructor(options, ...params) {
    super(options, ...params);
    this.name = 'RememberMeValueNotValid';
    this.message = "Remember me value must be one of ".concat(JSON.stringify(Object.keys(options)), ".");
    this.status = statusCodes['Bad Request'];
  }

}

class auth_ParamsMissing extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'ParamsMissing';
    this.message = 'Parameters expected are missing.';
    this.status = statusCodes['Bad Request'];
  }

}

class auth_TrialExceededLimit extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'TrialExceededLimit';
    this.message = 'Trial exceeded limit of users.';
    this.status = statusCodes['Payment Required'];
  }

}

class auth_CurrentPasswordMissing extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'CurrentPasswordMissing';
    this.message = 'Current password missing.';
    this.status = statusCodes['Bad Request'];
  }

}

class auth_CurrentPasswordIncorrect extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'CurrentPasswordIncorrect';
    this.message = 'Current password is incorrect.';
    this.status = statusCodes['Unauthorized'];
  }

}

class auth_KeyNotFound extends Error {
  constructor(message, ...params) {
    super(message, ...params);
    this.name = 'KeyNotFound';
    this.message = message;
    this.status = statusCodes['Not Found'];
  }

}

/* harmony default export */ var auth = ({
  UsernameAlreadyExists: auth_UsernameAlreadyExists,
  UsernameMissing: auth_UsernameMissing,
  UsernameCannotBeBlank: auth_UsernameCannotBeBlank,
  UsernameTooLong: auth_UsernameTooLong,
  UsernameMustBeString: auth_UsernameMustBeString,
  PasswordMissing: auth_PasswordMissing,
  PasswordCannotBeBlank: auth_PasswordCannotBeBlank,
  PasswordTooShort: auth_PasswordTooShort,
  PasswordTooLong: auth_PasswordTooLong,
  PasswordMustBeString: auth_PasswordMustBeString,
  PasswordAttemptLimitExceeded: auth_PasswordAttemptLimitExceeded,
  UsernameOrPasswordMismatch: auth_UsernameOrPasswordMismatch,
  UserAlreadySignedIn: auth_UserAlreadySignedIn,
  UserPendingDeletion: auth_UserPendingDeletion,
  AppIdNotValid: auth_AppIdNotValid,
  UserNotSignedIn: auth_UserNotSignedIn,
  UserNotFound: auth_UserNotFound,
  UserEmailNotFound: auth_UserEmailNotFound,
  EmailNotValid: auth_EmailNotValid,
  ProfileMustBeObject: auth_ProfileMustBeObject,
  ProfileCannotBeEmpty: auth_ProfileCannotBeEmpty,
  ProfileHasTooManyKeys: auth_ProfileHasTooManyKeys,
  ProfileKeyTooLong: auth_ProfileKeyTooLong,
  ProfileValueMustBeString: auth_ProfileValueMustBeString,
  ProfileValueCannotBeBlank: auth_ProfileValueCannotBeBlank,
  ProfileValueTooLong: auth_ProfileValueTooLong,
  RememberMeValueNotValid: auth_RememberMeValueNotValid,
  ParamsMissing: auth_ParamsMissing,
  TrialExceededLimit: auth_TrialExceededLimit,
  CurrentPasswordMissing: auth_CurrentPasswordMissing,
  CurrentPasswordIncorrect: auth_CurrentPasswordIncorrect,
  KeyNotFound: auth_KeyNotFound
});
// CONCATENATED MODULE: ./src/errors/db.js


class db_DatabaseNameMissing extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'DatabaseNameMissing';
    this.message = 'Database name missing.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_DatabaseNameCannotBeBlank extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'DatabaseNameCannotBeBlank';
    this.message = 'Database name cannot be blank.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_DatabaseNameMustBeString extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'DatabaseNameMustBeString';
    this.message = 'Database name must be a string.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_DatabaseNameTooLong extends Error {
  constructor(maxLength, ...params) {
    super(maxLength, ...params);
    this.name = 'DatabaseNameTooLong';
    this.message = "Database name cannot be more than ".concat(maxLength, " characters.");
    this.status = statusCodes['Bad Request'];
  }

}

class db_DatabaseAlreadyOpening extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'DatabaseAlreadyOpening';
    this.message = 'Already attempting to open database.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_ChangeHandlerMissing extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'ChangeHandlerMissing';
    this.message = 'Change handler missing.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_ChangeHandlerMustBeFunction extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'ChangeHandlerMustBeFunction';
    this.message = 'Change handler must be a function.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_DatabaseNotOpen extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'DatabaseNotOpen';
    this.message = 'Database is not open.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_ItemMissing extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'ItemMissing';
    this.message = 'Item missing.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_ItemInvalid extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'ItemInvalid';
    this.message = 'Item must be serializable to JSON.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_ItemTooLarge extends Error {
  constructor(maxKb, ...params) {
    super(maxKb, ...params);
    this.name = 'ItemTooLarge';
    this.message = "Item must be less than ".concat(maxKb, " KB.");
    this.status = statusCodes['Bad Request'];
  }

}

class db_ItemIdMustBeString extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'ItemIdMustBeString';
    this.message = 'Item id must be a string.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_ItemIdTooLong extends Error {
  constructor(maxLength, ...params) {
    super(maxLength, ...params);
    this.name = 'ItemIdTooLong';
    this.message = "Item id cannot be more than ".concat(maxLength, " characters.");
    this.status = statusCodes['Bad Request'];
  }

}

class db_ItemIdMissing extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'ItemIdMissing';
    this.message = 'Item id missing.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_ItemIdCannotBeBlank extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'ItemIdCannotBeBlank';
    this.message = 'Item id cannot be blank.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_ItemAlreadyExists extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'ItemAlreadyExists';
    this.message = 'Item with the same id already exists.';
    this.status = statusCodes['Conflict'];
  }

}

class db_ItemDoesNotExist extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'ItemDoesNotExist';
    this.message = 'Item with the provided id does not exist.';
    this.status = statusCodes['Not Found'];
  }

}

class db_ItemUpdateConflict extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'ItemUpdateConflict';
    this.message = 'Item update conflict.';
    this.status = statusCodes['Conflict'];
  }

}

class db_OperationsMissing extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'OperationsMissing';
    this.message = 'Operations missing.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_OperationsMustBeArray extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'OperationsMustBeArray';
    this.message = 'Operations provided must be an array.';
    this.status = statusCodes['Bad Request'];
  }

}

class db_CommandNotRecognized extends Error {
  constructor(command, ...params) {
    super(command, ...params);
    this.name = 'CommandNotRecognized';
    this.message = "Command '".concat(command, "' not recognized.");
    this.status = statusCodes['Bad Request'];
  }

}

class db_OperationsConflict extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'OperationsConflict';
    this.message = 'Operations conflict. Only allowed 1 operation per item.';
    this.status = statusCodes['Conflict'];
  }

}

class db_OperationsExceedLimit extends Error {
  constructor(limit, ...params) {
    super(limit, ...params);
    this.name = 'OperationsExceedLimit';
    this.message = "Operations exceed limit. Only allowed ".concat(limit, " operations.");
    this.status = statusCodes['Bad Request'];
  }

}

/* harmony default export */ var errors_db = ({
  DatabaseNameMissing: db_DatabaseNameMissing,
  DatabaseNameCannotBeBlank: db_DatabaseNameCannotBeBlank,
  DatabaseNameMustBeString: db_DatabaseNameMustBeString,
  DatabaseNameTooLong: db_DatabaseNameTooLong,
  DatabaseAlreadyOpening: db_DatabaseAlreadyOpening,
  ChangeHandlerMissing: db_ChangeHandlerMissing,
  ChangeHandlerMustBeFunction: db_ChangeHandlerMustBeFunction,
  DatabaseNotOpen: db_DatabaseNotOpen,
  ItemMissing: db_ItemMissing,
  ItemInvalid: db_ItemInvalid,
  ItemTooLarge: db_ItemTooLarge,
  ItemIdMustBeString: db_ItemIdMustBeString,
  ItemIdTooLong: db_ItemIdTooLong,
  ItemIdMissing: db_ItemIdMissing,
  ItemIdCannotBeBlank: db_ItemIdCannotBeBlank,
  ItemAlreadyExists: db_ItemAlreadyExists,
  ItemDoesNotExist: db_ItemDoesNotExist,
  ItemUpdateConflict: db_ItemUpdateConflict,
  OperationsMissing: db_OperationsMissing,
  OperationsMustBeArray: db_OperationsMustBeArray,
  OperationsConflict: db_OperationsConflict,
  OperationsExceedLimit: db_OperationsExceedLimit,
  CommandNotRecognized: db_CommandNotRecognized
});
// CONCATENATED MODULE: ./src/errors/config.js


class config_AppIdAlreadySet extends Error {
  constructor(appId, ...params) {
    super(appId, ...params);
    this.name = 'AppIdAlreadySet';
    this.message = 'Application ID already set.';
    this.status = statusCodes['Conflict'];
    this.appId = appId;
  }

}

class config_AppIdMustBeString extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'AppIdMustBeString';
    this.message = 'Application ID must be a string.';
    this.status = statusCodes['Bad Request'];
  }

}

class config_AppIdMissing extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'AppIdMissing';
    this.message = 'Application ID missing.';
    this.status = statusCodes['Bad Request'];
  }

}

class config_AppIdCannotBeBlank extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'AppIdCannotBeBlank';
    this.message = 'Application ID cannot be blank.';
    this.status = statusCodes['Bad Request'];
  }

}

class config_WebCryptoUnavailable extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'WebCryptoUnavailable';
    this.message = 'The WebCrypto API is unavailable. Please make sure your website uses https.';
    this.status = statusCodes['Bad Request'];
  }

}

/* harmony default export */ var config = ({
  AppIdAlreadySet: config_AppIdAlreadySet,
  AppIdMustBeString: config_AppIdMustBeString,
  AppIdMissing: config_AppIdMissing,
  AppIdCannotBeBlank: config_AppIdCannotBeBlank,
  WebCryptoUnavailable: config_WebCryptoUnavailable
});
// CONCATENATED MODULE: ./src/errors/payments.js


class payments_SuccessUrlMissing extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'SuccessUrlMissing';
    this.message = 'Success url missing to let Stripe know where to redirect users on successful payment.';
    this.status = statusCodes['Bad Request'];
  }

}

class payments_SuccessUrlMustBeString extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'SuccessUrlMustBeString';
    this.message = 'Success url must be a string.';
    this.status = statusCodes['Bad Request'];
  }

}

class payments_SuccessUrlInvalid extends Error {
  constructor(invalidProtocol, ...params) {
    super(invalidProtocol, ...params);
    this.name = 'SuccessUrlInvalid';
    this.message = invalidProtocol ? 'Success url must start with http or https.' : 'Success url invalid.';
    this.status = statusCodes['Bad Request'];
  }

}

class payments_CancelUrlMissing extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'CancelUrlMissing';
    this.message = 'Cancel url missing to let Stripe know where to redirect users on cancelled payment.';
    this.status = statusCodes['Bad Request'];
  }

}

class payments_CancelUrlMustBeString extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'CancelUrlMustBeString';
    this.message = 'Cancel url must be a string.';
    this.status = statusCodes['Bad Request'];
  }

}

class payments_CancelUrlInvalid extends Error {
  constructor(invalidProtocol, ...params) {
    super(invalidProtocol, ...params);
    this.name = 'CancelUrlInvalid';
    this.message = invalidProtocol ? 'Cancel url must start with http or https.' : 'Cancel url invalid.';
    this.status = statusCodes['Bad Request'];
  }

}

class payments_StripeJsLibraryMissing extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'StripeLibraryMissing';
    this.message = 'Stripe.js library missing. Be sure to include the script in your html file (https://stripe.com/docs/stripe-js#setup).';
    this.status = statusCodes['Bad Request'];
  }

}

class payments_PaymentsDisabled extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'PaymentsDisabled';
    this.message = 'Payments on this app are disabled. Enable payments in the admin panel.';
    this.status = statusCodes['Forbidden'];
  }

}

class payments_SubscriptionPlanNotSet extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'SubscriptionPlanNotSet';
    this.message = 'Subscription plan not set. Set the subscription plan in the admin panel.';
    this.status = statusCodes['Forbidden'];
  }

}

class payments_SubscriptionPlanAlreadyPurchased extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'SubscriptionPlanAlreadyPurchased';
    this.message = 'Subscription plan already purchased.';
    this.status = statusCodes['Conflict'];
  }

}

class payments_StripeAccountNotConnected extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'StripeAccountNotConnected';
    this.message = 'Stripe account not connected. Connect a Stripe account in the admin panel.';
    this.status = statusCodes['Forbidden'];
  }

}

class payments_SubscriptionNotFound extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'SubscriptionNotFound';
    this.message = 'Subscription not found. User must purchase a subscription.';
    this.status = statusCodes['Payment Required'];
  }

}

class payments_SubscribedToIncorrectPlan extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'SubscribedToIncorrectPlan';
    this.message = "Subscribed to the incorrect subscription plan. The user must purchase the app's current subscription plan.";
    this.status = statusCodes['Payment Required'];
  }

}

class payments_SubscriptionInactive extends Error {
  constructor(subscriptionStatus, ...params) {
    super(...params);
    this.name = 'SubscriptionInactive';
    this.message = "The user's subscription is inactive.";
    this.subscriptionStatus = subscriptionStatus;
    this.status = statusCodes['Payment Required'];
  }

}

class payments_SubscriptionNotPurchased extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'SubscriptionNotPurchased';
    this.message = 'Subscription not purchased. User must purchase a subscription.';
    this.status = statusCodes['Payment Required'];
  }

}

class payments_SubscriptionAlreadyCanceled extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'SubscriptionAlreadyCanceled';
    this.message = 'Subscription already canceled. User must purchase a new subscription.';
    this.status = statusCodes['Bad Request'];
  }

}

class payments_TrialExpired extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'TrialExpired';
    this.message = 'Trial expired. User must purchase a subscription.';
    this.status = statusCodes['Payment Required'];
  }

}

class StripeError extends Error {
  constructor(error, ...params) {
    super(error, ...params);
    const {
      status,
      type,
      message
    } = error;
    this.name = 'StripeError';
    this.message = message;
    this.type = type;
    this.status = status;
  }

}

/* harmony default export */ var payments = ({
  SuccessUrlMissing: payments_SuccessUrlMissing,
  SuccessUrlMustBeString: payments_SuccessUrlMustBeString,
  SuccessUrlInvalid: payments_SuccessUrlInvalid,
  CancelUrlMissing: payments_CancelUrlMissing,
  CancelUrlMustBeString: payments_CancelUrlMustBeString,
  CancelUrlInvalid: payments_CancelUrlInvalid,
  StripeJsLibraryMissing: payments_StripeJsLibraryMissing,
  PaymentsDisabled: payments_PaymentsDisabled,
  SubscriptionPlanNotSet: payments_SubscriptionPlanNotSet,
  SubscriptionPlanAlreadyPurchased: payments_SubscriptionPlanAlreadyPurchased,
  StripeAccountNotConnected: payments_StripeAccountNotConnected,
  SubscriptionNotFound: payments_SubscriptionNotFound,
  SubscribedToIncorrectPlan: payments_SubscribedToIncorrectPlan,
  SubscriptionInactive: payments_SubscriptionInactive,
  SubscriptionNotPurchased: payments_SubscriptionNotPurchased,
  SubscriptionAlreadyCanceled: payments_SubscriptionAlreadyCanceled,
  TrialExpired: payments_TrialExpired,
  StripeError
});
// CONCATENATED MODULE: ./src/errors/index.js


function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }







class errors_AppIdNotSet extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'AppIdNotSet';
    this.message = 'App ID not set yet. Make sure to configure app ID.';
    this.status = statusCodes['Bad Request'];
  }

}

class errors_ServiceUnavailable extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'ServiceUnavailable';
    this.message = 'Service unavailable.';
    this.status = statusCodes['Service Unavailable'];
  }

}

class errors_InternalServerError extends errors_ServiceUnavailable {
  constructor(...params) {
    super(...params);
    this.status = statusCodes['Internal Server Error'];
  }

}

class errors_Timeout extends errors_ServiceUnavailable {
  constructor(...params) {
    super(...params);
    this.status = statusCodes['Gateway Timeout'];
  }

}

class Reconnecting extends errors_ServiceUnavailable {
  constructor(...params) {
    super(...params);
    this.message = 'Reconnecting.';
  }

}

class UnknownServiceUnavailable extends errors_ServiceUnavailable {
  constructor(e, ...params) {
    super(e, ...params);
    console.error('Userbase error. Please report this to support@userbase.com.\n\n', e);
  }

}

class errors_ParamsMustBeObject extends Error {
  constructor(...params) {
    super(...params);
    this.name = 'ParamsMustBeObject';
    this.message = 'Parameters passed to function must be placed inside an object.';
    this.status = statusCodes['Bad Request'];
  }

}

class errors_TooManyRequests extends Error {
  constructor(retryDelay, ...params) {
    super(retryDelay, ...params);
    const retryDelaySeconds = Math.floor(retryDelay / 1000);
    this.name = 'TooManyRequests';
    this.message = "Too many requests in a row. Please try again in ".concat(retryDelaySeconds, " second").concat(retryDelaySeconds !== 1 ? 's' : '', ".");
    this.status = statusCodes['Too Many Requests'];
  }

}

/* harmony default export */ var errors = (_objectSpread({}, auth, {}, errors_db, {}, config, {}, payments, {
  AppIdNotSet: errors_AppIdNotSet,
  InternalServerError: errors_InternalServerError,
  ServiceUnavailable: errors_ServiceUnavailable,
  Timeout: errors_Timeout,
  Reconnecting,
  UnknownServiceUnavailable,
  ParamsMustBeObject: errors_ParamsMustBeObject,
  TooManyRequests: errors_TooManyRequests
}));
// CONCATENATED MODULE: ./src/config.js

const VERSION = '/v1';
const DEFAULT_ENDPOINT = 'https://v1.userbase.com' + VERSION;
const STRIPE_PRODUCTION_PUBLISHABLE_KEY = 'pk_live_jI6lbsAIQlu2u4uTkDXFrSEW';
const STRIPE_TEST_PUBLISHABLE_KEY = 'pk_test_rYANrLdNfdJXJ2d808wW4pqY';
let userbaseAppId = null;
const REMEMBER_ME_OPTIONS = {
  local: true,
  session: true,
  none: true
};

const getAppId = () => {
  if (!userbaseAppId) throw new errors.AppIdNotSet();
  return userbaseAppId;
};

const getEndpoint = () => {
  return window._userbaseEndpoint || DEFAULT_ENDPOINT;
};

const setAppId = appId => {
  if (userbaseAppId && userbaseAppId !== appId) throw new errors.AppIdAlreadySet(userbaseAppId);
  if (typeof appId !== 'string') throw new errors.AppIdMustBeString();
  if (appId.length === 0) throw new errors.AppIdCannotBeBlank();
  userbaseAppId = appId;
};

const configure = ({
  appId
}) => {
  setAppId(appId);
};

const getStripePublishableKey = isProduction => {
  return isProduction ? window._USERBASE_STRIPE_PRODUCTION_PUBLISHABLE_KEY || STRIPE_PRODUCTION_PUBLISHABLE_KEY : window._USERBASE_STRIPE_TEST_PUBLISHABLE_KEY || STRIPE_TEST_PUBLISHABLE_KEY;
};

/* harmony default export */ var src_config = ({
  REMEMBER_ME_OPTIONS,
  getAppId,
  getEndpoint,
  configure,
  getStripePublishableKey
});
// CONCATENATED MODULE: ./src/api/auth.js


const TEN_SECONDS_MS = 10 * 1000;

class RequestError extends Error {
  constructor(data, status, statusText, ...params) {
    super(data, status, statusText, ...params);
    this.response = {
      data,
      status,
      statusText
    };
    this.message = 'Request failed with status code ' + status;
  }

}

class TimeoutError extends Error {
  constructor(timeout, ...params) {
    super(timeout, ...params);
    this.message = "timeout of ".concat(timeout, "ms exceeded");
  }

}

const handleResponse = (xhr, resolve, reject) => {
  let response;

  try {
    response = JSON.parse(xhr.response);
  } catch (_unused) {
    response = xhr.response;
  }

  if (xhr.status >= 200 && xhr.status < 300) {
    resolve(response);
  } else {
    reject(new RequestError(response, xhr.status, xhr.statusText));
  }
};

const processXhr = (xhr, resolve, reject) => {
  xhr.timeout = TEN_SECONDS_MS;

  xhr.onload = () => handleResponse(xhr, resolve, reject);

  xhr.onerror = () => reject(new errors.ServiceUnavailable());

  xhr.ontimeout = () => reject(new TimeoutError(TEN_SECONDS_MS));
};

const signUp = (username, passwordToken, publicKey, passwordSalts, keySalts, email, profile, passwordBasedBackup) => {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    const method = 'POST';
    const url = "".concat(src_config.getEndpoint(), "/api/auth/sign-up?appId=").concat(src_config.getAppId());
    const data = JSON.stringify({
      username,
      passwordToken,
      publicKey,
      passwordSalts,
      keySalts,
      email,
      profile,
      passwordBasedBackup
    });
    xhr.open(method, url);
    xhr.setRequestHeader('Content-Type', 'application/json');
    xhr.send(data);
    processXhr(xhr, resolve, reject);
  });
};

const getPasswordSalts = username => {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    const method = 'GET';
    const url = "".concat(src_config.getEndpoint(), "/api/auth/get-password-salts?appId=").concat(src_config.getAppId(), "&username=").concat(encodeURIComponent(username));
    xhr.open(method, url);
    xhr.send();
    processXhr(xhr, resolve, reject);
  });
};

const signIn = async (username, passwordToken) => {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    const method = 'POST';
    const url = "".concat(src_config.getEndpoint(), "/api/auth/sign-in?appId=").concat(src_config.getAppId());
    const data = JSON.stringify({
      username,
      passwordToken
    });
    xhr.open(method, url);
    xhr.setRequestHeader('Content-Type', 'application/json');
    xhr.send(data);
    processXhr(xhr, resolve, reject);
  });
};

const signInWithSession = sessionId => {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    const method = 'POST';
    const url = "".concat(src_config.getEndpoint(), "/api/auth/sign-in-with-session?appId=").concat(src_config.getAppId(), "&sessionId=").concat(sessionId);
    xhr.open(method, url);
    xhr.send();
    processXhr(xhr, resolve, reject);
  });
};

const getServerPublicKey = async () => {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    const method = 'GET';
    const url = "".concat(src_config.getEndpoint(), "/api/auth/server-public-key");
    const responseType = 'arraybuffer';
    xhr.open(method, url);
    xhr.responseType = responseType;
    xhr.send();
    processXhr(xhr, resolve, reject);
  });
};

/* harmony default export */ var api_auth = ({
  signUp,
  getPasswordSalts,
  signIn,
  signInWithSession,
  getServerPublicKey
});
// CONCATENATED MODULE: ./src/api/index.js

/* harmony default export */ var api = ({
  auth: api_auth
});
// EXTERNAL MODULE: external "uuid/v4"
var v4_ = __webpack_require__(2);
var v4_default = /*#__PURE__*/__webpack_require__.n(v4_);

// EXTERNAL MODULE: external "lz-string"
var external_lz_string_ = __webpack_require__(3);
var external_lz_string_default = /*#__PURE__*/__webpack_require__.n(external_lz_string_);

// CONCATENATED MODULE: ./src/localData.js


function localData_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function localData_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { localData_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { localData_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const tryCatchWrapper = func => (...args) => {
  try {
    return func(...args);
  } catch (e) {
    // ok to swallow error
    //
    // local/sessionStorage are non-critical benefits. If they happen to be available,
    // they're helpful, but if not, the SDK functions totally fine.
    //
    // If a function fails, behavior is functionally the same as if rememberMe is 'none'.
    console.warn('Error accessing browser storage. Defaulting to memory.\n\n', e);
  }
};

const _getSeedName = (appId, username) => "userbaseSeed.".concat(appId, ".").concat(username);

const setCurrentSession = tryCatchWrapper((rememberMe, username, signedIn, sessionId, creationDate, expirationDate) => {
  const session = {
    username,
    signedIn,
    sessionId,
    creationDate,
    expirationDate
  };
  const sessionString = JSON.stringify(session);

  if (rememberMe === 'local') {
    localStorage.setItem('userbaseCurrentSession', sessionString);
  } else if (rememberMe === 'session') {
    sessionStorage.setItem('userbaseCurrentSession', sessionString);
  }
});
const getCurrentSession = tryCatchWrapper(() => {
  const sessionStorageCurrentSessionString = sessionStorage.getItem('userbaseCurrentSession');

  if (sessionStorageCurrentSessionString) {
    const currentSession = JSON.parse(sessionStorageCurrentSessionString);

    if (!currentSession.signedIn) {
      const localCurrentSessionString = localStorage.getItem('userbaseCurrentSession');

      if (localCurrentSessionString) {
        const localCurrentSession = JSON.parse(localCurrentSessionString); // allows session from localStorage to override sessionStorage if signed in
        // to localStorage session and not signed in to sessionStorage session

        if (localCurrentSession.signedIn) {
          return localData_objectSpread({}, localCurrentSession, {
            rememberMe: 'local'
          });
        }
      }
    }

    return localData_objectSpread({}, JSON.parse(sessionStorageCurrentSessionString), {
      rememberMe: 'session'
    });
  }

  const localSessionString = localStorage.getItem('userbaseCurrentSession');
  return localSessionString && localData_objectSpread({}, JSON.parse(localSessionString), {
    rememberMe: 'local'
  });
});
const saveSeedString = tryCatchWrapper((rememberMe, appId, username, seedString) => {
  if (rememberMe === 'local') {
    localStorage.setItem(_getSeedName(appId, username), seedString);
  } else if (rememberMe === 'session') {
    sessionStorage.setItem(_getSeedName(appId, username), seedString);
  }
});
const removeSeedString = tryCatchWrapper((appId, username) => {
  const seedName = _getSeedName(appId, username);

  sessionStorage.removeItem(seedName);
  localStorage.removeItem(seedName);
});
const getSeedString = tryCatchWrapper((appId, username) => {
  const seedName = _getSeedName(appId, username);

  return sessionStorage.getItem(seedName) || localStorage.getItem(seedName);
});

const signInSession = (rememberMe, username, sessionId, creationDate, expirationDate) => {
  const signedIn = true;
  setCurrentSession(rememberMe, username, signedIn, sessionId, creationDate, expirationDate);
};

const signOutSession = (rememberMe, username) => {
  const signedIn = false;
  setCurrentSession(rememberMe, username, signedIn);
};

const removeCurrentSession = tryCatchWrapper(() => {
  sessionStorage.removeItem('userbaseCurrentSession');
  localStorage.removeItem('userbaseCurrentSession');
});
/* harmony default export */ var localData = ({
  signInSession,
  signOutSession,
  getCurrentSession,
  saveSeedString,
  removeSeedString,
  getSeedString,
  removeCurrentSession
});
// CONCATENATED MODULE: ./src/Crypto/utils.js
const ONE_KB = 1024;
const TEN_KB = 10 * ONE_KB; // https://stackoverflow.com/a/20604561/11601853

const arrayBufferToString = buf => {
  const bufView = new Uint16Array(buf);
  const length = bufView.length;
  let result = '';
  let chunkSize = TEN_KB; // using chunks prevents stack from blowing up

  for (var i = 0; i < length; i += chunkSize) {
    if (i + chunkSize > length) {
      chunkSize = length - i;
    }

    const chunk = bufView.subarray(i, i + chunkSize);
    result += String.fromCharCode.apply(null, chunk);
  }

  return result;
}; // https://developers.google.com/web/updates/2012/06/How-to-convert-ArrayBuffer-to-and-from-String

const stringToArrayBuffer = str => {
  let buf = new ArrayBuffer(str.length * 2); // 2 bytes for each char

  let bufView = new Uint16Array(buf);

  for (let i = 0, strLen = str.length; i < strLen; i++) {
    bufView[i] = str.charCodeAt(i);
  }

  return buf;
};
/**
* Creates a new Uint8Array based on two different ArrayBuffers
*
* Source: https://gist.github.com/72lions/4528834
*
* @param {ArrayBuffers} buffer1 The first buffer.
* @param {ArrayBuffers} buffer2 The second buffer.
* @return {ArrayBuffers} The new ArrayBuffer created out of the two.
*
*/

const appendBuffer = (buffer1, buffer2) => {
  const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);
  tmp.set(new Uint8Array(buffer1), 0);
  tmp.set(new Uint8Array(buffer2), buffer1.byteLength);
  return tmp.buffer;
};
const appendBuffers = buffers => {
  const bufferByteLengths = buffers.map(buffer => buffer.byteLength);
  const totalByteLength = bufferByteLengths.reduce((byteLengthSum, bufferByteLength) => byteLengthSum + bufferByteLength);
  const tmp = new Uint8Array(totalByteLength);
  let currentByteLength = 0;

  for (let i = 0; i < buffers.length; i++) {
    tmp.set(new Uint8Array(buffers[i]), currentByteLength);
    currentByteLength += bufferByteLengths[i];
  }

  return {
    buffer: tmp.buffer,
    byteLengths: bufferByteLengths
  };
};
const hexStringToArrayBuffer = hexString => {
  if (hexString.length % 2 !== 0) throw new Error('Hex string must be even length');
  const halfHexStringLen = hexString.length / 2;
  const array = [];

  for (let i = 0; i < halfHexStringLen; i++) {
    const byteStartIndex = i * 2;
    const byte = hexString.substring(byteStartIndex, byteStartIndex + 2);
    const byteAsInt = parseInt(byte, 16);
    array.push(byteAsInt);
  }

  return new Uint8Array(array);
};
// CONCATENATED MODULE: ./src/Crypto/sha-256.js


const BYTE_SIZE = 32; // 256 / 8

const HASH_ALGORITHM_NAME = 'SHA-256';
/**
 *
 * @param {ArrayBuffer} data
 */

const hash = async data => {
  const result = await window.crypto.subtle.digest({
    name: HASH_ALGORITHM_NAME
  }, data);
  return result;
};

const hashBase64String = async dataString => {
  const data = external_base64_arraybuffer_default.a.decode(dataString);
  const result = await hash(data);
  return external_base64_arraybuffer_default.a.encode(result);
};

const hashString = async dataString => {
  const data = stringToArrayBuffer(dataString);
  const result = await hash(data);
  return external_base64_arraybuffer_default.a.encode(result);
};

/* harmony default export */ var sha_256 = ({
  BYTE_SIZE,
  HASH_ALGORITHM_NAME,
  hash,
  hashBase64String,
  hashString
});
// CONCATENATED MODULE: ./src/Crypto/hkdf.js



const HKDF_ALGORITHM_NAME = 'HKDF';
const RAW_KEY_TYPE = 'raw';
const KEY_IS_NOT_EXTRACTABLE = false;
const KEY_WILL_BE_USED_TO = ['deriveKey', 'deriveBits'];

const importHkdfKeyFromString = async seedString => {
  const seed = stringToArrayBuffer(seedString);
  const hkdfKey = await importHkdfKey(seed);
  return hkdfKey;
};

const importHkdfKey = async seed => {
  const hkdfKey = await window.crypto.subtle.importKey(RAW_KEY_TYPE, seed, {
    name: HKDF_ALGORITHM_NAME
  }, KEY_IS_NOT_EXTRACTABLE, KEY_WILL_BE_USED_TO);
  return hkdfKey;
};
/**
 *  RFC 5869:
 *
 *  "the use of salt adds significantly to the strength of HKDF...
 *  Ideally, the salt value is a random (or pseudorandom) string of the
 *  length HashLen"
 *
 *  https://tools.ietf.org/html/rfc5869#section-3.1
 *
 **/


const SALT_BYTE_SIZE = sha_256.BYTE_SIZE;

const generateSalt = () => window.crypto.getRandomValues(new Uint8Array(SALT_BYTE_SIZE));

const getParams = (keyName, salt) => ({
  name: HKDF_ALGORITHM_NAME,
  info: stringToArrayBuffer(keyName),
  hash: sha_256.HASH_ALGORITHM_NAME,
  salt
});

const PASSWORD_TOKEN_NAME = 'password-token';
const PASSWORD_TOKEN_NUM_BITS = 256;

const getPasswordToken = async (hkdfKey, salt) => {
  const passwordTokenBits = await window.crypto.subtle.deriveBits(getParams(PASSWORD_TOKEN_NAME, salt), hkdfKey, PASSWORD_TOKEN_NUM_BITS);
  return external_base64_arraybuffer_default.a.encode(passwordTokenBits);
};

/* harmony default export */ var hkdf = ({
  importHkdfKeyFromString,
  importHkdfKey,
  generateSalt,
  getParams,
  getPasswordToken
});
// CONCATENATED MODULE: ./src/Crypto/aes-gcm.js



const ENCRYPTION_ALGORITHM_NAME = 'AES-GCM';
const BIT_SIZE = 256;
const KEY_IS_EXTRACTABLE = true;
const aes_gcm_KEY_WILL_BE_USED_TO = ['encrypt', 'decrypt'];
const aes_gcm_RAW_KEY_TYPE = 'raw';
const ENCRYPTION_KEY_NAME = 'encryption';
const PASSWORD_BASED_ENCRYPTION_KEY = 'password-based-encryption';
/**
 * NIST recommendation:
 *
 * "For  IVs,  it  is  recommended  that  implementations  restrict  support  to
 * the  length  of  96  bits,  to  promote interoperability, efficiency, and
 * simplicity of design."
 *
 * Pg. 8
 * https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf
 *
 **/

const RECOMMENDED_IV_BYTE_SIZE = 12; // 96 / 8

/**
 * Source on tag length:
 * https://crypto.stackexchange.com/questions/26783/ciphertext-and-tag-size-and-iv-transmission-with-aes-in-gcm-mode/26787
 */

const RECOMMENDED_AUTHENTICATION_TAG_LENGTH = 128;

const windowOrSelfObject = () => {
  return typeof window !== 'undefined' ? window : self;
};

const getEncryptionKeyParams = () => ({
  name: ENCRYPTION_ALGORITHM_NAME,
  length: BIT_SIZE
});

const importKeyFromMaster = async (masterKey, salt) => {
  const encryptionKey = await window.crypto.subtle.deriveKey(hkdf.getParams(ENCRYPTION_KEY_NAME, salt), masterKey, getEncryptionKeyParams(), KEY_IS_EXTRACTABLE, aes_gcm_KEY_WILL_BE_USED_TO);
  return encryptionKey;
};

const generateKey = async () => {
  const key = await window.crypto.subtle.generateKey(getEncryptionKeyParams(), KEY_IS_EXTRACTABLE, aes_gcm_KEY_WILL_BE_USED_TO);
  return key;
};

const getKeyStringFromKey = async key => {
  const rawKey = await window.crypto.subtle.exportKey(aes_gcm_RAW_KEY_TYPE, key);
  const keyString = external_base64_arraybuffer_default.a.encode(rawKey);
  return keyString;
};

const getKeyFromKeyString = async keyString => {
  const rawKey = external_base64_arraybuffer_default.a.decode(keyString);
  const key = await getKeyFromRawKey(rawKey);
  return key;
};

const getKeyFromRawKey = async rawKey => {
  const key = await windowOrSelfObject().crypto.subtle.importKey(aes_gcm_RAW_KEY_TYPE, rawKey, {
    name: ENCRYPTION_ALGORITHM_NAME
  }, KEY_IS_EXTRACTABLE, aes_gcm_KEY_WILL_BE_USED_TO);
  return key;
};

const getRawKeyFromKey = async key => {
  const rawKey = await windowOrSelfObject().crypto.subtle.exportKey(aes_gcm_RAW_KEY_TYPE, key);
  return rawKey;
};
/**
 *
 * @param {CryptoKey} key
 * @param {ArrayBuffer} plaintext
 * @returns {ArrayBuffer} encrypted Array Buffer
 *
 *     encrypted is a concatentation of Array Buffers [ciphertext, auth tag, IV]
 *
 *     The Authentication Tag is a hash of the plaintext to ensure the same data that
 *     is ecncrypted is the resulting data when decrypted. Note that the browser crypto
 *     library's result is the concatenation of Array Buffers [ciphertext, auth tag]
 *
 *     The IV is a random intialization vector that prevents an attacker
 *     from determining a user's key. It can be exposed alongside the ciphertext safely.
 *
 */


const encrypt = async (key, plaintext) => {
  const iv = windowOrSelfObject().crypto.getRandomValues(new Uint8Array(RECOMMENDED_IV_BYTE_SIZE)); // this result is the concatenation of Array Buffers [ciphertext, auth tag]

  const ciphertextArrayBuffer = await windowOrSelfObject().crypto.subtle.encrypt({
    name: ENCRYPTION_ALGORITHM_NAME,
    iv,
    tagLength: RECOMMENDED_AUTHENTICATION_TAG_LENGTH
  }, key, plaintext);
  return appendBuffer(ciphertextArrayBuffer, iv);
};

const encryptJson = async (key, plaintextJson) => {
  const plaintextString = JSON.stringify(plaintextJson);
  const encrypted = await encryptString(key, plaintextString);
  return encrypted;
};

const encryptString = async (key, plaintextString) => {
  const plaintextArrayBuffer = stringToArrayBuffer(plaintextString);
  const encrypted = await encrypt(key, plaintextArrayBuffer);
  return external_base64_arraybuffer_default.a.encode(encrypted);
};
/**
 *
 * @param {CryptoKey} key
 * @param {ArrayBuffer} encrypted - the encrypted Array Buffer
 * @returns {object} plaintext
 */


const decrypt = async (key, encrypted) => {
  const ivStartIndex = encrypted.byteLength - RECOMMENDED_IV_BYTE_SIZE;
  const ciphertextArrayBuffer = encrypted.slice(0, ivStartIndex);
  const iv = encrypted.slice(ivStartIndex);
  const plaintextArrayBuffer = await windowOrSelfObject().crypto.subtle.decrypt({
    name: ENCRYPTION_ALGORITHM_NAME,
    iv,
    tagLength: RECOMMENDED_AUTHENTICATION_TAG_LENGTH
  }, key, ciphertextArrayBuffer);
  return plaintextArrayBuffer;
};

const decryptJson = async (key, encryptedJsonString) => {
  const plaintextString = await decryptString(key, encryptedJsonString);
  return JSON.parse(plaintextString);
};

const decryptString = async (key, encryptedString) => {
  const encryptedArrayBuffer = external_base64_arraybuffer_default.a.decode(encryptedString);
  const plaintextArrayBuffer = await decrypt(key, encryptedArrayBuffer);
  const plaintextString = arrayBufferToString(plaintextArrayBuffer);
  return plaintextString;
};

const getPasswordBasedEncryptionKey = async (hkdfKey, salt) => {
  const encryptionKey = await window.crypto.subtle.deriveKey(hkdf.getParams(PASSWORD_BASED_ENCRYPTION_KEY, salt), hkdfKey, getEncryptionKeyParams(), !KEY_IS_EXTRACTABLE, aes_gcm_KEY_WILL_BE_USED_TO);
  return encryptionKey;
};

/* harmony default export */ var aes_gcm = ({
  getEncryptionKeyParams,
  importKeyFromMaster,
  generateKey,
  getKeyStringFromKey,
  getKeyFromKeyString,
  getRawKeyFromKey,
  getKeyFromRawKey,
  encrypt,
  encryptJson,
  encryptString,
  decrypt,
  decryptJson,
  decryptString,
  getPasswordBasedEncryptionKey
});
// EXTERNAL MODULE: external "diffie-hellman"
var external_diffie_hellman_ = __webpack_require__(4);
var external_diffie_hellman_default = /*#__PURE__*/__webpack_require__.n(external_diffie_hellman_);

// CONCATENATED MODULE: ./src/Crypto/diffie-hellman.js






const diffie_hellman_KEY_IS_EXTRACTABLE = true;
const diffie_hellman_KEY_WILL_BE_USED_TO = ['encrypt']; // unused

const DIFFIE_HELLMAN_KEY_NAME = 'diffie-hellman'; // RFC 3526 detailing publicly known 2048 bit safe prime: https://www.ietf.org/rfc/rfc3526.txt

const PRIME = hexStringToArrayBuffer('ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff');
const GENERATOR = [2]; // get public key from the server to allow developers to easily swap out default server with their own
// server running userbase-server

let serverPublicKey = null;

const diffie_hellman_getServerPublicKey = async () => {
  if (serverPublicKey) {
    return serverPublicKey;
  } else {
    serverPublicKey = await api.auth.getServerPublicKey(); // eslint-disable-line require-atomic-updates

    return serverPublicKey;
  }
};

const setPrivateKeyAndGenerateKeys = (diffieHellman, privateKey) => {
  diffieHellman.setPrivateKey(privateKey);
  diffieHellman.generateKeys();
  return diffieHellman;
};

const createDiffieHellman = privateKey => {
  const diffieHellman = external_diffie_hellman_default.a.createDiffieHellman(PRIME, GENERATOR);
  return setPrivateKeyAndGenerateKeys(diffieHellman, privateKey);
};

const getSharedKey = async (privateKey, otherPublicKey) => {
  const diffieHellman = createDiffieHellman(privateKey);
  const sharedSecret = diffieHellman.computeSecret(otherPublicKey);
  const sharedRawKey = await sha_256.hash(sharedSecret);
  const sharedKey = await aes_gcm.getKeyFromRawKey(sharedRawKey);
  return sharedKey;
};

const getPublicKey = privateKey => {
  const diffieHellman = createDiffieHellman(privateKey);
  return diffieHellman.getPublicKey();
};

const getSharedKeyWithServer = async privateKey => {
  const sharedKey = await getSharedKey(privateKey, new Uint8Array((await diffie_hellman_getServerPublicKey())));
  return sharedKey;
};

const diffie_hellman_importKeyFromMaster = async (masterKey, salt) => {
  const privateKey = await window.crypto.subtle.deriveKey(hkdf.getParams(DIFFIE_HELLMAN_KEY_NAME, salt), masterKey, aes_gcm.getEncryptionKeyParams(), // DH not supported, using raw AES key as secret instead
  diffie_hellman_KEY_IS_EXTRACTABLE, diffie_hellman_KEY_WILL_BE_USED_TO);
  const rawPrivateKey = await aes_gcm.getRawKeyFromKey(privateKey);
  return rawPrivateKey;
};

/* harmony default export */ var diffie_hellman = ({
  getPublicKey,
  getSharedKey,
  getSharedKeyWithServer,
  importKeyFromMaster: diffie_hellman_importKeyFromMaster
});
// CONCATENATED MODULE: ./src/Crypto/hmac.js




const HMAC_KEY_NAME = 'authentication';
const ALGORITHM_NAME = 'HMAC';
const hmac_KEY_IS_EXTRACTABLE = false;
const hmac_KEY_WILL_BE_USED_TO = ['sign'];

const hmac_importKeyFromMaster = async (masterKey, salt) => {
  const hmacKey = await window.crypto.subtle.deriveKey(hkdf.getParams(HMAC_KEY_NAME, salt), masterKey, {
    name: ALGORITHM_NAME,
    hash: {
      name: sha_256.HASH_ALGORITHM_NAME
    }
  }, hmac_KEY_IS_EXTRACTABLE, hmac_KEY_WILL_BE_USED_TO);
  return hmacKey;
};
/**
 *
 * @param {CryptoKey} key
 * @param {String} data
 */


const sign = async (key, data) => {
  const result = await window.crypto.subtle.sign({
    name: ALGORITHM_NAME
  }, key, data);
  return result;
};
/**
 *
 * @param {CryptoKey} key
 * @param {String} data
 */


const signString = async (key, data) => {
  const result = await sign(key, stringToArrayBuffer(data));
  return external_base64_arraybuffer_default.a.encode(result);
};

/* harmony default export */ var hmac = ({
  importKeyFromMaster: hmac_importKeyFromMaster,
  sign,
  signString
});
// EXTERNAL MODULE: external "scrypt-js"
var external_scrypt_js_ = __webpack_require__(5);
var external_scrypt_js_default = /*#__PURE__*/__webpack_require__.n(external_scrypt_js_);

// CONCATENATED MODULE: ./src/Crypto/scrypt.js



/**
 *
 * From the Scrypt paper:
 *
 * "100ms is a reasonable upper bound on the delay which should be
 * cryptographically imposed on interactive logins"
 *
 * Pg. 13
 * https://www.tarsnap.com/scrypt/scrypt.pdf
 *
 * With an optimized Scrypt algorithm running on a 3.1 GHz Intel Core i5,
 * N = 32768 is the highest work factor that takes <100ms for the
 * algorithm to run. Thus, it's the latest recommended work factor.
 *
 * Source: https://blog.filippo.io/the-scrypt-parameters/
 *
 * However, we are not running an optimized version of the algorithm on a
 * single machine. Users are running a pure js version written for the browser.
 * Safari, for example, takes >6 seconds to run when N = 32768 on a 2.5 GHz
 * Intel Core i5. A higher end CPU can only shave around 1 second off that time.
 * Further, it takes over 1s to run in Firefox, and over 500ms to run in Chrome.
 * This is an unacceptably slow interactive login delay to impose on users.
 *
 * Thus, we are going with N = 16384 to ensure interactive logins
 * are closer to the reasonable delay the function will impose on users,
 * while still maintaining a high level of security.
 *
 **/

const N = 16384; // 16mb

const r = 8;
const p = 1;
const HASH_LENGTH = 32;
/**
 * NIST recommendation:
 *
 * "The length of the randomly-generated portion of the salt shall be at least 128 bits."
 *
 * Section 5.1
 * https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf
 *
 **/

const SALT_LENGTH = 16;

const scrypt_generateSalt = () => window.crypto.getRandomValues(new Uint8Array(SALT_LENGTH));

const scrypt_hash = async (passwordString, salt) => {
  const passwordArrayBuffer = new Uint8Array(stringToArrayBuffer(passwordString));
  const passwordHash = await external_scrypt_js_default.a.scrypt(passwordArrayBuffer, salt, N, r, p, HASH_LENGTH);
  return external_base64_arraybuffer_default.a.encode(passwordHash);
};

/* harmony default export */ var scrypt = ({
  generateSalt: scrypt_generateSalt,
  hash: scrypt_hash
});
// CONCATENATED MODULE: ./src/Crypto/index.js






const SEED_BYTE_SIZE = 32; // 256 / 8

const generateSeed = () => window.crypto.getRandomValues(new Uint8Array(SEED_BYTE_SIZE));

/* harmony default export */ var Crypto = ({
  generateSeed,
  aesGcm: aes_gcm,
  diffieHellman: diffie_hellman,
  sha256: sha_256,
  hmac: hmac,
  hkdf: hkdf,
  scrypt: scrypt
});
// CONCATENATED MODULE: ./src/utils.js
const readArrayBufferAsString = arrayBuffer => {
  return new Promise(resolve => {
    let reader = new FileReader();

    reader.onload = () => resolve(reader.result);

    reader.readAsText(new Blob([arrayBuffer]));
  });
};

const removeProtocolFromEndpoint = endpoint => {
  const http = 'http://';
  const https = 'https://';

  if (endpoint.substring(0, http.length) === http) {
    return endpoint.substring(http.length);
  } else if (endpoint.substring(0, https.length) === https) {
    return endpoint.substring(https.length);
  } else {
    return endpoint;
  }
};

const getProtocolFromEndpoint = endpoint => {
  return endpoint.split(':')[0];
};
const getWsUrl = endpoint => {
  const host = removeProtocolFromEndpoint(endpoint);
  const protocol = getProtocolFromEndpoint(endpoint);
  return (protocol === 'https' ? 'wss://' : 'ws://') + host;
};
const byteSizeOfString = string => {
  return string.length * 2;
};
const objectHasOwnProperty = (object, property) => {
  return Object.prototype.hasOwnProperty.call(object, property);
}; // source: http://code.iamkate.com/javascript/queues

function Queue() {
  let queue = [];
  let offset = 0;

  this.getLength = () => queue.length - offset;

  this.isEmpty = () => queue.length === 0;

  this.enqueue = item => {
    queue.push(item);
    return this.getLength();
  };

  this.dequeue = () => {
    // get item from front of the queue
    const item = queue[offset];
    offset += 1; // garbage collect unused space in queue when it grows large

    if (offset * 2 > queue.length) {
      queue = queue.slice(offset);
      offset = 0;
    }

    return item;
  };

  this.peek = () => queue[offset];
}
// CONCATENATED MODULE: ./src/ws.js


function ws_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function ws_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ws_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ws_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }










const wsAlreadyConnected = 'Web Socket already connected';
const BACKOFF_RETRY_DELAY = 1000;
const MAX_RETRY_DELAY = 1000 * 30;
const clientId = v4_default()(); // only 1 client ID per browser tab (assumes code does not reload)

class ws_RequestFailed extends Error {
  constructor(action, e, ...params) {
    super(...params);
    this.name = "RequestFailed: ".concat(action);
    this.message = e.message;
    this.status = e.status || e.message === 'timeout' && statusCodes['Gateway Timeout'];
    this.response = e.status && e;
  }

}

class WebSocketError extends Error {
  constructor(message, username, ...params) {
    super(...params);
    this.name = 'WebSocket error';
    this.message = message;
    this.username = username;
  }

}

class ws_Connection {
  constructor() {
    this.init();
  }

  init(resolveConnection, rejectConnection, session, seedString, rememberMe, state) {
    if (this.pingTimeout) clearTimeout(this.pingTimeout);

    for (const property of Object.keys(this)) {
      delete this[property];
    }

    this.ws = null;
    this.connected = false;
    this.resolveConnection = resolveConnection;
    this.rejectConnection = rejectConnection;
    this.connectionResolved = false;
    this.session = {
      username: session && session.username,
      sessionId: session && session.sessionId,
      creationDate: session && session.creationDate,
      authToken: session && session.authToken
    };
    this.seedString = seedString;
    this.keys = {
      init: false,
      salts: {}
    };
    this.userData = {
      stripeData: {}
    };
    this.rememberMe = rememberMe;
    this.requests = {};
    this.state = state || {
      databases: {},
      dbIdToHash: {},
      dbNameToHash: {}
    };
  }

  connect(session, seedString = null, rememberMe, reconnectDelay, state) {
    if (this.connected) throw new WebSocketError(wsAlreadyConnected, this.session.username);
    return new Promise((resolve, reject) => {
      let timeout = false;
      const timeoutToOpenWebSocket = setTimeout(() => {
        if (!this.connected && !this.reconnecting) {
          timeout = true;
          reject(new WebSocketError('timeout'));
        }
      }, 10000);
      const url = "".concat(getWsUrl(src_config.getEndpoint()), "/api?appId=").concat(src_config.getAppId(), "&sessionId=").concat(session.sessionId, "&clientId=").concat(clientId);
      const ws = new WebSocket(url);

      ws.onopen = async () => {
        if (timeout) return;
        clearTimeout(timeoutToOpenWebSocket);
      };

      ws.onmessage = async e => {
        if (timeout) return;

        try {
          const message = JSON.parse(e.data);
          const route = message.route;

          switch (route) {
            case 'Ping':
              {
                this.heartbeat();
                const action = 'Pong';
                this.ws.send(JSON.stringify({
                  action
                }));
                break;
              }

            case 'Connection':
              {
                this.init(resolve, reject, session, seedString, rememberMe, state);
                this.ws = ws;
                this.heartbeat();
                this.connected = true;
                const {
                  keySalts,
                  encryptedValidationMessage
                } = message;
                this.keys.salts = keySalts;
                this.encryptedValidationMessage = new Uint8Array(encryptedValidationMessage.data);
                await this.setKeys(this.seedString);
                break;
              }

            case 'ApplyTransactions':
              {
                const dbId = message.dbId;
                const dbNameHash = message.dbNameHash || this.state.dbIdToHash[dbId];
                const database = this.state.databases[dbNameHash];
                if (!database) throw new Error('Missing database'); // queue guarantees transactions will be applied in the order they are received from the server

                if (database.applyTransactionsQueue.isEmpty()) {
                  // take a spot in the queue and proceed applying so the next caller knows queue is not empty
                  database.applyTransactionsQueue.enqueue(null);
                } else {
                  // wait until prior batch in queue finishes applying successfully
                  await new Promise(resolve => {
                    const startApplyingThisBatchOfTransactions = resolve;
                    database.applyTransactionsQueue.enqueue(startApplyingThisBatchOfTransactions);
                  });
                }

                const openingDatabase = message.dbNameHash && message.dbKey;

                if (openingDatabase) {
                  const dbKeyString = await Crypto.aesGcm.decryptString(this.keys.encryptionKey, message.dbKey);
                  database.dbKeyString = dbKeyString;
                  database.dbKey = await Crypto.aesGcm.getKeyFromKeyString(dbKeyString);
                }

                if (!database.dbKey) throw new Error('Missing db key');

                if (message.bundle) {
                  const bundleSeqNo = message.bundleSeqNo;
                  const base64Bundle = message.bundle;
                  const compressedString = await Crypto.aesGcm.decryptString(database.dbKey, base64Bundle);
                  const plaintextString = external_lz_string_default.a.decompress(compressedString);
                  const bundle = JSON.parse(plaintextString);
                  database.applyBundle(bundle, bundleSeqNo);
                }

                const newTransactions = message.transactionLog;
                await database.applyTransactions(newTransactions);

                if (!database.init) {
                  this.state.dbIdToHash[dbId] = dbNameHash;
                  database.dbId = dbId;
                  database.init = true;
                  database.receivedMessage();
                }

                if (message.buildBundle) {
                  this.buildBundle(database);
                } // start applying next batch in queue when this one is finished applying successfully


                database.applyTransactionsQueue.dequeue();

                if (!database.applyTransactionsQueue.isEmpty()) {
                  const startApplyingNextBatchInQueue = database.applyTransactionsQueue.peek();
                  startApplyingNextBatchInQueue();
                }

                break;
              }

            case 'SignOut':
            case 'UpdateUser':
            case 'DeleteUser':
            case 'CreateDatabase':
            case 'GetDatabase':
            case 'OpenDatabase':
            case 'GetDatabases':
            case 'Insert':
            case 'Update':
            case 'Delete':
            case 'BatchTransaction':
            case 'Bundle':
            case 'ValidateKey':
            case 'GetPasswordSalts':
            case 'PurchaseSubscription':
            case 'CancelSubscription':
            case 'ResumeSubscription':
            case 'UpdatePaymentMethod':
              {
                const requestId = message.requestId;
                if (!requestId) return console.warn('Missing request id');
                const request = this.requests[requestId];
                if (!request) return console.warn("Request ".concat(requestId, " no longer exists!"));else if (!request.promiseResolve || !request.promiseReject) return;
                const response = message.response;
                const successfulResponse = response && response.status === statusCodes['Success'];
                if (!successfulResponse) return request.promiseReject(response);else return request.promiseResolve(response);
              }

            default:
              {
                console.log('Received unknown message from backend:' + JSON.stringify(message));
                break;
              }
          }
        } catch (e) {
          if (!this.connectionResolved) {
            this.close();
            reject(new WebSocketError(e.message, session.username));
          } else {
            console.warn('Error handling message: ', e);
          }
        }
      };

      ws.onclose = async e => {
        if (timeout) return;
        const serviceRestart = e.code === statusCodes['Service Restart'];
        const clientDisconnected = e.code === statusCodes['No Pong Received'];
        const attemptToReconnect = serviceRestart || clientDisconnected || !e.wasClean; // closed without explicit call to ws.close()

        if (attemptToReconnect) {
          const delay = serviceRestart && !reconnectDelay ? 0 : reconnectDelay ? reconnectDelay + BACKOFF_RETRY_DELAY : 1000;
          this.reconnecting = true;
          await this.reconnect(resolve, reject, session, seedString, rememberMe, delay, !this.reconnected && state);
        } else if (e.code === statusCodes['Client Already Connected']) {
          reject(new WebSocketError(wsAlreadyConnected, session.username));
        } else {
          this.init();
        }
      };
    });
  }

  async reconnect(resolveConnection, rejectConnection, session, seedString, rememberMe, reconnectDelay, currentState) {
    try {
      const retryDelay = Math.min(reconnectDelay, MAX_RETRY_DELAY);
      console.log("Connection to server lost. Attempting to reconnect in ".concat(retryDelay / 1000, " second").concat(retryDelay !== 1000 ? 's' : '', "..."));
      const dbsToReopen = []; // as soon as one reconnect succeeds, resolves all the way up the stack and all reconnects succeed

      resolveConnection((await new Promise((resolve, reject) => setTimeout(async () => {
        try {
          const state = currentState || {
            databases: ws_objectSpread({}, this.state.databases),
            dbIdToHash: ws_objectSpread({}, this.state.dbIdToHash),
            dbNameToHash: ws_objectSpread({}, this.state.dbNameToHash)
          };

          for (const dbNameHash in state.databases) {
            state.databases[dbNameHash].init = false;
            dbsToReopen.push(dbNameHash);
          }

          this.init();
          this.reconnecting = true;
          const result = await this.connect(session, seedString, rememberMe, reconnectDelay, state);
          this.reconnected = true; // only reopen databases on the first call to reconnect()

          if (!currentState) await this.reopenDatabases(dbsToReopen, 1000);
          resolve(result);
        } catch (e) {
          reject(e);
        }
      }, retryDelay))));
    } catch (e) {
      rejectConnection(e);
    }
  }

  async reopenDatabases(dbsToReopen, retryDelay) {
    try {
      const openDatabasePromises = [];

      for (const dbNameHash of dbsToReopen) {
        const database = this.state.databases[dbNameHash];

        if (!database.init) {
          const action = 'OpenDatabase';
          const params = {
            dbNameHash,
            reopenAtSeqNo: database.lastSeqNo
          };
          openDatabasePromises.push(this.request(action, params));
        }
      }

      await Promise.all(openDatabasePromises);
    } catch (e) {
      // keep attempting to reopen on failure
      await new Promise(resolve => setTimeout(async () => {
        await this.reopenDatabases(dbsToReopen, retryDelay + BACKOFF_RETRY_DELAY);
        resolve();
      }, Math.min(retryDelay, MAX_RETRY_DELAY)));
    }
  }

  heartbeat() {
    clearTimeout(this.pingTimeout);
    const LATENCY_BUFFER = 3000;
    this.pingTimeout = setTimeout(() => {
      if (this.ws) this.ws.close(statusCodes['No Pong Received']);
    }, 30000 + LATENCY_BUFFER);
  }

  close(code) {
    this.ws ? this.ws.close(code) : this.init();
  }

  async signOut() {
    const username = this.session.username;
    const connectionResolved = this.connectionResolved;
    const rejectConnection = this.rejectConnection;

    try {
      localData.signOutSession(this.rememberMe, username);
      const sessionId = this.session.sessionId;
      if (this.reconnecting) throw new errors.Reconnecting();
      const action = 'SignOut';
      const params = {
        sessionId
      };
      await this.request(action, params);
      this.close();

      if (!connectionResolved && rejectConnection) {
        rejectConnection(new WebSocketError('Canceled', username));
      }
    } catch (e) {
      if (!connectionResolved && rejectConnection) {
        rejectConnection(new WebSocketError('Canceled', username));
      }

      throw e;
    }
  }

  async setKeys(seedString) {
    if (this.keys.init) return;
    if (!seedString) throw new WebSocketError('Missing seed', this.session.username);
    if (!this.keys.salts) throw new WebSocketError('Missing salts', this.session.username);
    if (!this.seedString) this.seedString = seedString;
    const seed = external_base64_arraybuffer_default.a.decode(seedString);
    const masterKey = await Crypto.hkdf.importHkdfKey(seed);
    const salts = this.keys.salts;
    this.keys.encryptionKey = await Crypto.aesGcm.importKeyFromMaster(masterKey, external_base64_arraybuffer_default.a.decode(salts.encryptionKeySalt));
    this.keys.dhPrivateKey = await Crypto.diffieHellman.importKeyFromMaster(masterKey, external_base64_arraybuffer_default.a.decode(salts.dhKeySalt));
    this.keys.hmacKey = await Crypto.hmac.importKeyFromMaster(masterKey, external_base64_arraybuffer_default.a.decode(salts.hmacKeySalt));
    const userData = await this.validateKey();
    this.userData = userData;
    this.keys.init = true;
    this.resolveConnection();
    this.connectionResolved = true;
  }

  async validateKey() {
    const sharedKey = await Crypto.diffieHellman.getSharedKeyWithServer(this.keys.dhPrivateKey);
    const validationMessage = external_base64_arraybuffer_default.a.encode((await Crypto.aesGcm.decrypt(sharedKey, this.encryptedValidationMessage)));
    const action = 'ValidateKey';
    const params = {
      validationMessage
    };
    const response = await this.request(action, params);
    const userData = response.data;
    return userData;
  }

  async request(action, params) {
    // generate a new requestId
    const requestId = v4_default()();
    this.requests[requestId] = {}; // get a promise that is resolved when the WebSocket
    // receives a response for this requestId  the promise
    // would time out of x seconds

    const responseWatcher = this.watch(requestId); // send the request on the WebSocket

    this.ws.send(JSON.stringify({
      requestId,
      action,
      params
    })); // wait for the response to arrive

    try {
      const response = await responseWatcher;
      return response;
    } catch (e) {
      // process any errors and re-throw them
      if (e.status === statusCodes['Too Many Requests']) throw new errors.TooManyRequests(e.data.retryDelay);else throw new ws_RequestFailed(action, e);
    }
  }

  async watch(requestId) {
    const response = await new Promise((resolve, reject) => {
      this.requests[requestId].promiseResolve = resolve;
      this.requests[requestId].promiseReject = reject;
      setTimeout(() => {
        reject(new Error('timeout'));
      }, 10000);
    });
    delete this.requests[requestId];
    return response;
  }

  async buildBundle(database) {
    const bundle = {
      items: database.items,
      itemsIndex: database.itemsIndex.array
    };
    const plaintextString = JSON.stringify(bundle);
    const dbId = database.dbId;
    const lastSeqNo = database.lastSeqNo;
    const dbKey = database.dbKey;
    const itemKeyPromises = [];

    for (let i = 0; i < bundle.itemsIndex.length; i++) {
      const itemId = bundle.itemsIndex[i].itemId;
      itemKeyPromises.push(Crypto.hmac.signString(this.keys.hmacKey, itemId));
    }

    const itemKeys = await Promise.all(itemKeyPromises);
    const compressedString = external_lz_string_default.a.compress(plaintextString);
    const base64Bundle = await Crypto.aesGcm.encryptString(dbKey, compressedString);
    const action = 'Bundle';
    const params = {
      dbId,
      seqNo: lastSeqNo,
      bundle: base64Bundle,
      keys: itemKeys
    };
    this.request(action, params);
  }

}

/* harmony default export */ var src_ws = (new ws_Connection());
// CONCATENATED MODULE: ./src/auth.js


function auth_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function auth_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { auth_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { auth_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }










const MAX_PASSWORD_CHAR_LENGTH = 1000;
const MIN_PASSWORD_CHAR_LENGTH = 6;

const _parseGenericErrors = e => {
  if (e.response) {
    if (e.response.data === 'App ID not valid') {
      throw new errors.AppIdNotValid();
    } else if (e.response.data === 'UserNotFound') {
      throw new errors.UserNotFound();
    } else if (e.response.status === statusCodes['Internal Server Error']) {
      throw new errors.InternalServerError();
    } else if (e.response.status === statusCodes['Gateway Timeout']) {
      throw new errors.Timeout();
    }
  } else if (e.message && e.message.indexOf('timeout') !== -1) {
    throw new errors.Timeout();
  }
};

const _connectWebSocket = async (session, seed, rememberMe) => {
  try {
    await src_ws.connect(session, seed, rememberMe);
  } catch (e) {
    _parseGenericErrors(e);

    if (e.message === 'Web Socket already connected') {
      throw new errors.UserAlreadySignedIn(e.username);
    }

    throw e;
  }
};

const _parseGenericUsernamePasswordError = e => {
  if (e.response && e.response.data.error === 'UsernameTooLong') {
    throw new errors.UsernameTooLong(e.response.data.maxLen);
  } else if (e.response && e.response.data.error === 'PasswordAttemptLimitExceeded') {
    throw new errors.PasswordAttemptLimitExceeded(e.response.data.delay);
  }
};

const _parseUserResponseError = (e, username) => {
  _parseGenericErrors(e);

  _parseGenericUsernamePasswordError(e);

  if (e.response) {
    const data = e.response.data;

    switch (data) {
      case 'UsernameAlreadyExists':
        throw new errors.UsernameAlreadyExists(username);

      case 'TrialExceededLimit':
        throw new errors.TrialExceededLimit();

      case 'CurrentPasswordIncorrect':
        throw new errors.CurrentPasswordIncorrect();

      default: // continue

    }

    switch (data.error) {
      case 'EmailNotValid':
        throw new errors.EmailNotValid();

      case 'ProfileMustBeObject':
        throw new errors.ProfileMustBeObject();

      case 'ProfileKeyTooLong':
        throw new errors.ProfileKeyTooLong(data.maxLen, data.key);

      case 'ProfileValueMustBeString':
        throw new errors.ProfileValueMustBeString(data.key, data.value);

      case 'ProfileValueCannotBeBlank':
        throw new errors.ProfileValueCannotBeBlank(data.key);

      case 'ProfileValueTooLong':
        throw new errors.ProfileValueTooLong(data.maxLen, data.key, data.value);

      case 'ProfileHasTooManyKeys':
        throw new errors.ProfileHasTooManyKeys(data.maxKeys);

      case 'ProfileCannotBeEmpty':
        throw new errors.ProfileCannotBeEmpty();
    }
  }

  throw e;
};

const _validateUsername = username => {
  if (typeof username !== 'string') throw new errors.UsernameMustBeString();
  if (username.length === 0) throw new errors.UsernameCannotBeBlank();
};

const _validatePassword = password => {
  if (typeof password !== 'string') throw new errors.PasswordMustBeString();
  if (password.length === 0) throw new errors.PasswordCannotBeBlank();
  if (password.length < MIN_PASSWORD_CHAR_LENGTH) throw new errors.PasswordTooShort(MIN_PASSWORD_CHAR_LENGTH);
  if (password.length > MAX_PASSWORD_CHAR_LENGTH) throw new errors.PasswordTooLong(MAX_PASSWORD_CHAR_LENGTH);
};

const _validateSignUpOrSignInInput = params => {
  if (typeof params !== 'object') throw new errors.ParamsMustBeObject();
  if (!objectHasOwnProperty(params, 'username')) throw new errors.UsernameMissing();
  if (!objectHasOwnProperty(params, 'password')) throw new errors.PasswordMissing();

  _validateUsername(params.username);

  _validatePassword(params.password);

  if (objectHasOwnProperty(params, 'rememberMe') && !src_config.REMEMBER_ME_OPTIONS[params.rememberMe]) {
    throw new errors.RememberMeValueNotValid(src_config.REMEMBER_ME_OPTIONS);
  }
};

const _generatePasswordToken = async (password, seed) => {
  const passwordSalt = Crypto.scrypt.generateSalt();
  const passwordHash = await Crypto.scrypt.hash(password, passwordSalt);
  const passwordHkdfKey = await Crypto.hkdf.importHkdfKeyFromString(passwordHash);
  const passwordTokenSalt = Crypto.hkdf.generateSalt();
  const passwordToken = await Crypto.hkdf.getPasswordToken(passwordHkdfKey, passwordTokenSalt);
  const passwordBasedEncryptionKeySalt = Crypto.hkdf.generateSalt();
  const passwordBasedEncryptionKey = await Crypto.aesGcm.getPasswordBasedEncryptionKey(passwordHkdfKey, passwordBasedEncryptionKeySalt);
  const passwordEncryptedSeed = await Crypto.aesGcm.encrypt(passwordBasedEncryptionKey, seed);
  const passwordSalts = {
    passwordSalt: external_base64_arraybuffer_default.a.encode(passwordSalt),
    passwordTokenSalt: external_base64_arraybuffer_default.a.encode(passwordTokenSalt)
  };
  const passwordBasedBackup = {
    passwordBasedEncryptionKeySalt: external_base64_arraybuffer_default.a.encode(passwordBasedEncryptionKeySalt),
    passwordEncryptedSeed: external_base64_arraybuffer_default.a.encode(passwordEncryptedSeed)
  };
  return {
    passwordToken,
    passwordSalts,
    passwordBasedBackup
  };
};

const _generateKeysAndSignUp = async (username, password, seed, email, profile) => {
  const {
    passwordToken,
    passwordSalts,
    passwordBasedBackup
  } = await _generatePasswordToken(password, seed);
  const masterKey = await Crypto.hkdf.importHkdfKey(seed);
  const encryptionKeySalt = Crypto.hkdf.generateSalt();
  const dhKeySalt = Crypto.hkdf.generateSalt();
  const hmacKeySalt = Crypto.hkdf.generateSalt();
  const dhPrivateKey = await Crypto.diffieHellman.importKeyFromMaster(masterKey, dhKeySalt);
  const publicKey = Crypto.diffieHellman.getPublicKey(dhPrivateKey);
  const keySalts = {
    encryptionKeySalt: external_base64_arraybuffer_default.a.encode(encryptionKeySalt),
    dhKeySalt: external_base64_arraybuffer_default.a.encode(dhKeySalt),
    hmacKeySalt: external_base64_arraybuffer_default.a.encode(hmacKeySalt)
  };

  try {
    const session = await api.auth.signUp(username, passwordToken, publicKey, passwordSalts, keySalts, email, profile, passwordBasedBackup);
    return session;
  } catch (e) {
    _parseUserResponseError(e, username);
  }
};

const _buildUserResult = ({
  username,
  userId,
  authToken,
  email,
  profile,
  protectedProfile,
  usedTempPassword,
  userData
}) => {
  const result = {
    username,
    userId,
    authToken
  };
  if (email) result.email = email;
  if (profile) result.profile = profile;
  if (protectedProfile) result.protectedProfile = protectedProfile;
  if (usedTempPassword) result.usedTempPassword = usedTempPassword;

  if (userData) {
    const {
      creationDate,
      stripeData
    } = userData;
    if (creationDate) result.creationDate = creationDate;

    if (stripeData) {
      const {
        paymentsMode,
        subscriptionStatus,
        cancelSubscriptionAt,
        trialExpirationDate
      } = stripeData;
      if (paymentsMode) result.paymentsMode = paymentsMode;
      if (subscriptionStatus) result.subscriptionStatus = subscriptionStatus;
      if (cancelSubscriptionAt) result.cancelSubscriptionAt = cancelSubscriptionAt;
      if (trialExpirationDate) result.trialExpirationDate = trialExpirationDate;
    }
  }

  return result;
};

const _validateProfile = profile => {
  if (typeof profile !== 'object') throw new errors.ProfileMustBeObject();
  let keyExists = false;

  for (const key in profile) {
    keyExists = true;
    const value = profile[key];
    if (typeof value !== 'string') throw new errors.ProfileValueMustBeString(key, value);
    if (!value) throw new errors.ProfileValueCannotBeBlank(key);
  }

  if (!keyExists) throw new errors.ProfileCannotBeEmpty();
};

const _validateSignUpInput = params => {
  _validateSignUpOrSignInInput(params);

  if (params.profile) _validateProfile(params.profile);
  if (params.email && typeof params.email !== 'string') throw new errors.EmailNotValid();
};

const auth_signUp = async params => {
  try {
    _validateSignUpInput(params);

    const {
      password,
      profile,
      rememberMe = 'session'
    } = params;
    const username = params.username.toLowerCase();
    const email = params.email && params.email.toLowerCase();
    const appId = src_config.getAppId();
    const seed = await Crypto.generateSeed();
    const {
      sessionId,
      creationDate,
      expirationDate,
      userId,
      authToken
    } = await _generateKeysAndSignUp(username, password, seed, email, profile);
    const session = {
      username,
      sessionId,
      creationDate,
      expirationDate,
      authToken
    };
    const seedString = external_base64_arraybuffer_default.a.encode(seed);
    localData.saveSeedString(rememberMe, appId, username, seedString);
    localData.signInSession(rememberMe, username, sessionId, creationDate, expirationDate);
    await _connectWebSocket(session, seedString, rememberMe);
    return _buildUserResult({
      username,
      userId,
      authToken,
      email,
      profile,
      userData: src_ws.userData
    });
  } catch (e) {
    switch (e.name) {
      case 'ParamsMustBeObject':
      case 'UsernameMissing':
      case 'UsernameAlreadyExists':
      case 'UsernameCannotBeBlank':
      case 'UsernameMustBeString':
      case 'UsernameTooLong':
      case 'PasswordMissing':
      case 'PasswordCannotBeBlank':
      case 'PasswordTooShort':
      case 'PasswordTooLong':
      case 'PasswordMustBeString':
      case 'EmailNotValid':
      case 'ProfileMustBeObject':
      case 'ProfileCannotBeEmpty':
      case 'ProfileHasTooManyKeys':
      case 'ProfileKeyTooLong':
      case 'ProfileValueMustBeString':
      case 'ProfileValueCannotBeBlank':
      case 'ProfileValueTooLong':
      case 'RememberMeValueNotValid':
      case 'TrialExceededLimit':
      case 'AppIdNotSet':
      case 'AppIdNotValid':
      case 'UserAlreadySignedIn':
      case 'ServiceUnavailable':
        throw e;

      default:
        throw new errors.UnknownServiceUnavailable(e);
    }
  }
};

const signOut = async () => {
  try {
    if (!src_ws.session.username) throw new errors.UserNotSignedIn();

    try {
      await src_ws.signOut();
    } catch (e) {
      _parseGenericErrors(e);

      throw e;
    }
  } catch (e) {
    switch (e.name) {
      case 'UserNotSignedIn':
      case 'ServiceUnavailable':
        throw e;

      default:
        throw new errors.UnknownServiceUnavailable(e);
    }
  }
};

const _getSeedStringFromPasswordBasedBackup = async (passwordHkdfKey, passwordBasedBackup) => {
  const {
    passwordBasedEncryptionKeySalt,
    passwordEncryptedSeed
  } = passwordBasedBackup;
  const passwordBasedEncryptionKey = await Crypto.aesGcm.getPasswordBasedEncryptionKey(passwordHkdfKey, external_base64_arraybuffer_default.a.decode(passwordBasedEncryptionKeySalt));
  const seedFromBackup = await Crypto.aesGcm.decrypt(passwordBasedEncryptionKey, external_base64_arraybuffer_default.a.decode(passwordEncryptedSeed));
  const seedStringFromBackup = external_base64_arraybuffer_default.a.encode(seedFromBackup);
  return seedStringFromBackup;
};

const _signInWrapper = async (username, passwordToken) => {
  try {
    const apiSignInResult = await api.auth.signIn(username, passwordToken);
    return apiSignInResult;
  } catch (e) {
    _parseGenericErrors(e);

    _parseGenericUsernamePasswordError(e);

    if (e.response && e.response.data === 'Invalid password') {
      throw new errors.UsernameOrPasswordMismatch();
    } else if (e.response && e.response.data === 'User pending deletion') {
      throw new errors.UserPendingDeletion();
    }

    throw e;
  }
};

const _getPasswordSaltsOverRestEndpoint = async username => {
  try {
    const passwordSalts = await api.auth.getPasswordSalts(username);
    return passwordSalts;
  } catch (e) {
    _parseGenericErrors(e);

    _parseGenericUsernamePasswordError(e);

    if (e.response && e.response.data === 'User not found') {
      throw new errors.UsernameOrPasswordMismatch();
    }

    throw e;
  }
};

const _getPasswordSaltsOverWebSocket = async () => {
  try {
    const action = 'GetPasswordSalts';
    const passwordSaltsResponse = await src_ws.request(action);
    return passwordSaltsResponse.data;
  } catch (e) {
    _parseGenericErrors(e);

    throw e;
  }
};

const _rebuildPasswordToken = async (password, passwordSalts) => {
  const {
    passwordSalt,
    passwordTokenSalt
  } = passwordSalts;
  const passwordHash = await Crypto.scrypt.hash(password, new Uint8Array(external_base64_arraybuffer_default.a.decode(passwordSalt)));
  const passwordHkdfKey = await Crypto.hkdf.importHkdfKeyFromString(passwordHash);
  const passwordToken = await Crypto.hkdf.getPasswordToken(passwordHkdfKey, external_base64_arraybuffer_default.a.decode(passwordTokenSalt));
  return {
    passwordHkdfKey,
    passwordToken
  };
};

const auth_signIn = async params => {
  try {
    _validateSignUpOrSignInInput(params);

    const username = params.username.toLowerCase();
    const {
      password,
      rememberMe = 'session'
    } = params;
    const appId = src_config.getAppId();
    const passwordSalts = await _getPasswordSaltsOverRestEndpoint(username);
    const {
      passwordHkdfKey,
      passwordToken
    } = await _rebuildPasswordToken(password, passwordSalts);
    const apiSignInResult = await _signInWrapper(username, passwordToken);
    const {
      userId,
      email,
      profile,
      passwordBasedBackup,
      protectedProfile,
      usedTempPassword
    } = apiSignInResult;

    const session = auth_objectSpread({}, apiSignInResult.session, {
      username
    });

    const savedSeedString = localData.getSeedString(appId, username);
    let seedStringFromBackup;

    if (!savedSeedString && usedTempPassword) {
      throw new errors.KeyNotFound("Your key was not found. You can only sign in with a temporary password from a device you've signed in from before.");
    } else if (!savedSeedString) {
      seedStringFromBackup = await _getSeedStringFromPasswordBasedBackup(passwordHkdfKey, passwordBasedBackup);
      localData.saveSeedString(rememberMe, appId, username, seedStringFromBackup);
    }

    const seedString = savedSeedString || seedStringFromBackup;
    localData.signInSession(rememberMe, username, session.sessionId, session.creationDate, session.expirationDate);
    await _connectWebSocket(session, seedString, rememberMe);
    return _buildUserResult({
      username,
      userId,
      authToken: session.authToken,
      email,
      profile,
      protectedProfile,
      usedTempPassword,
      userData: src_ws.userData
    });
  } catch (e) {
    switch (e.name) {
      case 'ParamsMustBeObject':
      case 'UsernameMissing':
      case 'UsernameOrPasswordMismatch':
      case 'UserPendingDeletion':
      case 'UsernameCannotBeBlank':
      case 'UsernameTooLong':
      case 'UsernameMustBeString':
      case 'PasswordMissing':
      case 'PasswordCannotBeBlank':
      case 'PasswordTooShort':
      case 'PasswordTooLong':
      case 'PasswordMustBeString':
      case 'PasswordAttemptLimitExceeded':
      case 'RememberMeValueNotValid':
      case 'KeyNotFound':
      case 'AppIdNotSet':
      case 'AppIdNotValid':
      case 'UserAlreadySignedIn':
      case 'ServiceUnavailable':
        throw e;

      default:
        throw new errors.UnknownServiceUnavailable(e);
    }
  }
};

const init = async params => {
  try {
    if (!window.crypto.subtle) throw new errors.WebCryptoUnavailable();
    if (typeof params !== 'object') throw new errors.ParamsMustBeObject();
    if (!objectHasOwnProperty(params, 'appId')) throw new errors.AppIdMissing();
    const {
      appId
    } = params;
    src_config.configure({
      appId
    });
    const session = await auth_signInWithSession(appId);
    return session;
  } catch (e) {
    switch (e.name) {
      case 'WebCryptoUnavailable':
      case 'ParamsMustBeObject':
      case 'AppIdMissing':
      case 'AppIdAlreadySet':
      case 'AppIdMustBeString':
      case 'AppIdCannotBeBlank':
      case 'AppIdNotValid':
      case 'UserAlreadySignedIn':
      case 'ServiceUnavailable':
        throw e;

      default:
        throw new errors.UnknownServiceUnavailable(e);
    }
  }
};

const auth_signInWithSession = async appId => {
  try {
    const currentSession = localData.getCurrentSession();
    if (!currentSession) return {};
    const {
      signedIn,
      sessionId,
      creationDate,
      expirationDate,
      rememberMe
    } = currentSession;
    const savedSeedString = localData.getSeedString(appId, currentSession.username);

    if (!signedIn || !savedSeedString || new Date() > new Date(expirationDate)) {
      return {
        lastUsedUsername: currentSession.username
      };
    }

    let apiSignInWithSessionResult;

    try {
      apiSignInWithSessionResult = await api.auth.signInWithSession(sessionId);
    } catch (e) {
      _parseGenericErrors(e);

      if (e.response && e.response.data === 'Session invalid') {
        return {
          lastUsedUsername: currentSession.username
        };
      }

      throw e;
    }

    const {
      userId,
      authToken,
      username,
      email,
      profile,
      protectedProfile
    } = apiSignInWithSessionResult; // overwrite local data if username has been changed on server

    if (username !== currentSession.username) {
      localData.saveSeedString(rememberMe, appId, username, savedSeedString);
      localData.removeSeedString(appId, currentSession.username);
    } // expirationDate should have been extended


    localData.signInSession(rememberMe, username, sessionId, creationDate, apiSignInWithSessionResult.expirationDate); // enable idempotent calls to init()

    if (src_ws.connectionResolved) {
      if (src_ws.session.sessionId === sessionId) {
        return {
          user: _buildUserResult({
            username,
            userId,
            authToken: src_ws.session.authToken,
            email,
            profile,
            protectedProfile,
            userData: src_ws.userData
          })
        };
      } else {
        throw new errors.UserAlreadySignedIn(src_ws.session.username);
      }
    }

    const session = auth_objectSpread({}, currentSession, {
      authToken
    });

    await _connectWebSocket(session, savedSeedString, rememberMe);
    return {
      user: _buildUserResult({
        username,
        userId,
        authToken,
        email,
        profile,
        protectedProfile,
        userData: src_ws.userData
      })
    };
  } catch (e) {
    _parseGenericErrors(e);

    throw e;
  }
};

const _validateUpdatedUserInput = params => {
  if (!objectHasOwnProperty(params, 'username') && !objectHasOwnProperty(params, 'newPassword') && !objectHasOwnProperty(params, 'email') && !objectHasOwnProperty(params, 'profile')) {
    throw new errors.ParamsMissing();
  }

  const {
    username,
    currentPassword,
    newPassword,
    email,
    profile
  } = params;
  if (objectHasOwnProperty(params, 'username')) _validateUsername(username);

  if (objectHasOwnProperty(params, 'newPassword')) {
    if (!currentPassword) throw new errors.CurrentPasswordMissing();

    _validatePassword(currentPassword);

    _validatePassword(newPassword);
  } // if email or profile are falsey, will be set to false


  if (email && typeof email !== 'string') throw new errors.EmailNotValid();
  if (profile) _validateProfile(profile);
};

const _buildUpdateUserParams = async params => {
  if (params.username) params.username = params.username.toLowerCase();

  if (params.newPassword) {
    const [currentPasswordSalts, newPasswordPromise] = await Promise.all([_getPasswordSaltsOverWebSocket(), _generatePasswordToken(params.newPassword, external_base64_arraybuffer_default.a.decode(src_ws.seedString))]); // current password

    const {
      passwordToken
    } = await _rebuildPasswordToken(params.currentPassword, currentPasswordSalts);
    params.currentPasswordToken = passwordToken;
    delete params.currentPassword; // new password

    params.passwordToken = newPasswordPromise.passwordToken;
    params.passwordSalts = newPasswordPromise.passwordSalts;
    params.passwordBasedBackup = newPasswordPromise.passwordBasedBackup;
    delete params.newPassword;
  }

  if (params.email) params.email = params.email.toLowerCase();else if (objectHasOwnProperty(params, 'email')) params.email = false; // marks email for deletion

  if (!params.profile && objectHasOwnProperty(params, 'profile')) params.profile = false; // marks profile for deletion

  return params;
};

const updateUser = async params => {
  try {
    if (typeof params !== 'object') throw new errors.ParamsMustBeObject();

    _validateUpdatedUserInput(params);

    if (!src_ws.keys.init) throw new errors.UserNotSignedIn();
    const startingSeedString = src_ws.seedString;
    const action = 'UpdateUser';
    const finalParams = await _buildUpdateUserParams(auth_objectSpread({}, params));
    if (src_ws.reconnecting) throw new errors.Reconnecting();
    if (!src_ws.keys.init) throw new errors.UserNotSignedIn(); // ensures same user still attempting to update (seed should remain constant)

    if (startingSeedString !== src_ws.seedString) throw new errors.ServiceUnavailable();

    try {
      if (finalParams.username) {
        localData.saveSeedString(src_ws.rememberMe, src_config.getAppId(), finalParams.username, src_ws.seedString);
      }

      await src_ws.request(action, finalParams);
    } catch (e) {
      _parseUserResponseError(e, finalParams.username);
    }
  } catch (e) {
    switch (e.name) {
      case 'ParamsMustBeObject':
      case 'ParamsMissing':
      case 'UsernameAlreadyExists':
      case 'UsernameMustBeString':
      case 'UsernameCannotBeBlank':
      case 'UsernameTooLong':
      case 'CurrentPasswordMissing':
      case 'CurrentPasswordIncorrect':
      case 'PasswordAttemptLimitExceeded':
      case 'PasswordMustBeString':
      case 'PasswordCannotBeBlank':
      case 'PasswordTooShort':
      case 'PasswordTooLong':
      case 'EmailNotValid':
      case 'ProfileMustBeObject':
      case 'ProfileCannotBeEmpty':
      case 'ProfileHasTooManyKeys':
      case 'ProfileKeyTooLong':
      case 'ProfileValueMustBeString':
      case 'ProfileValueCannotBeBlank':
      case 'ProfileValueTooLong':
      case 'AppIdNotSet':
      case 'AppIdNotValid':
      case 'UserNotFound':
      case 'UserNotSignedIn':
      case 'TooManyRequests':
      case 'ServiceUnavailable':
        throw e;

      default:
        throw new errors.UnknownServiceUnavailable(e);
    }
  }
};

const deleteUser = async () => {
  try {
    if (src_ws.reconnecting) throw new errors.Reconnecting();
    if (!src_ws.keys.init) throw new errors.UserNotSignedIn();
    const username = src_ws.session.username;
    localData.removeSeedString(username);
    localData.removeCurrentSession();

    try {
      const action = 'DeleteUser';
      await src_ws.request(action);
    } catch (e) {
      _parseGenericErrors(e);

      throw e;
    }

    src_ws.close();
  } catch (e) {
    switch (e.name) {
      case 'UserNotSignedIn':
      case 'UserNotFound':
      case 'TooManyRequests':
      case 'ServiceUnavailable':
        throw e;

      default:
        throw new errors.UnknownServiceUnavailable(e);
    }
  }
};

const forgotPassword = async params => {
  try {
    if (typeof params !== 'object') throw new errors.ParamsMustBeObject();
    if (!objectHasOwnProperty(params, 'username')) throw new errors.UsernameMissing();

    _validateUsername(params.username);

    const username = params.username.toLowerCase();
    const appId = src_config.getAppId();
    const seedString = localData.getSeedString(appId, username);
    const keyNotFoundMessage = "Your key was not found. Forgot password only works from a device you've signed in from before.";
    if (!seedString) throw new errors.KeyNotFound(keyNotFoundMessage);
    const seed = external_base64_arraybuffer_default.a.decode(seedString);
    const masterKey = await Crypto.hkdf.importHkdfKey(seed); // client makes 2 trips to server to first prove it has the correct key and then trigger the temp password email

    const forgotPasswordWs = new WebSocket("".concat(getWsUrl(src_config.getEndpoint()), "/api/auth/forgot-password?appId=").concat(appId, "&username=").concat(username));
    await new Promise((resolve, reject) => {
      setTimeout(() => reject(new errors.Timeout()), 15000);

      forgotPasswordWs.onerror = () => reject(new errors.ServiceUnavailable());

      forgotPasswordWs.onmessage = async e => {
        try {
          const message = JSON.parse(e.data);

          switch (message.route) {
            case 'ReceiveEncryptedToken':
              {
                // if client decrypts encrypted token successfully, proves to server it has the user's key
                const encryptedForgotPasswordToken = new Uint8Array(message.encryptedForgotPasswordToken.data);
                const dhPrivateKey = await Crypto.diffieHellman.importKeyFromMaster(masterKey, external_base64_arraybuffer_default.a.decode(message.dhKeySalt));
                const sharedKey = await Crypto.diffieHellman.getSharedKeyWithServer(dhPrivateKey);
                let forgotPasswordToken;

                try {
                  // if it fails to decrypt, it's almost certainly because key is incorrect
                  forgotPasswordToken = external_base64_arraybuffer_default.a.encode((await Crypto.aesGcm.decrypt(sharedKey, encryptedForgotPasswordToken)));
                } catch (_unused) {
                  throw new errors.KeyNotFound(keyNotFoundMessage);
                }

                forgotPasswordWs.send(JSON.stringify({
                  action: 'ForgotPassword',
                  params: {
                    forgotPasswordToken
                  }
                }));
                break;
              }

            case 'SuccessfullyForgotPassword':
              {
                // server has sent the email
                resolve();
                break;
              }

            case 'Error':
              {
                const data = message.data;

                switch (data.name) {
                  case 'UsernameTooLong':
                    throw new errors.UsernameTooLong(data.maxLen);

                  case 'AppIdNotValid':
                    throw new errors.AppIdNotValid();

                  case 'UserNotFound':
                    throw new errors.UserNotFound();

                  case 'UserEmailNotFound':
                    throw new errors.UserEmailNotFound();

                  default:
                    {
                      if (message.status === statusCodes['Internal Server Error']) throw new errors.ServiceUnavailable();else throw new errors.UnknownServiceUnavailable(data);
                    }
                }
              }

            case 'Ping':
              {
                // ignore -- websocket connection should only exist for the life of the forgot password request
                break;
              }

            default:
              reject(new Error("Received unknown message from userbase-server: ".concat(e.data)));
          }
        } catch (e) {
          reject(e);
        }
      };
    });
    forgotPasswordWs.close();
  } catch (e) {
    switch (e.name) {
      case 'ParamsMustBeObject':
      case 'UsernameMissing':
      case 'UsernameMustBeString':
      case 'UsernameCannotBeBlank':
      case 'UsernameTooLong':
      case 'AppIdNotSet':
      case 'AppIdNotValid':
      case 'KeyNotFound':
      case 'UserNotFound':
      case 'UserEmailNotFound':
      case 'ServiceUnavailable':
        throw e;

      default:
        throw new errors.UnknownServiceUnavailable(e);
    }
  }
};

/* harmony default export */ var src_auth = ({
  signUp: auth_signUp,
  signOut,
  signIn: auth_signIn,
  init,
  updateUser,
  deleteUser,
  forgotPassword
});
// EXTERNAL MODULE: external "sorted-array"
var external_sorted_array_ = __webpack_require__(6);
var external_sorted_array_default = /*#__PURE__*/__webpack_require__.n(external_sorted_array_);

// CONCATENATED MODULE: ./src/db.js


function db_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function db_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { db_ownKeys(Object(source), true).forEach(function (key) { defineProperty_default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { db_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }








const success = 'Success';
const MAX_DB_NAME_CHAR_LENGTH = 50;
const MAX_ITEM_ID_CHAR_LENGTH = 100;
const MAX_ITEM_KB = 10;
const db_TEN_KB = MAX_ITEM_KB * 1024;
const MAX_ITEM_BYTES = db_TEN_KB;

const db_parseGenericErrors = e => {
  if (e.response) {
    if (e.response.data === 'UserNotFound') {
      throw new errors.UserNotFound();
    } else if (e.response.status === statusCodes['Internal Server Error']) {
      throw new errors.InternalServerError();
    } else if (e.response.status === statusCodes['Gateway Timeout']) {
      throw new errors.Timeout();
    }
  } else if (e.message && e.message.indexOf('timeout') !== -1) {
    throw new errors.Timeout();
  }
};

class UnverifiedTransaction {
  constructor(startSeqNo) {
    this.startSeqNo = startSeqNo;
    this.txSeqNo = null;
    this.transactions = {};
    this.promiseResolve = null;
    this.promiseReject = null;
    this.index = null;
  }

  getStartSeqNo() {
    return this.startSeqNo;
  }

  getIndex() {
    return this.index;
  }

  setIndex(index) {
    this.index = index;
  }

  async getResult(seqNo) {
    this.txSeqNo = seqNo;
    const promise = new Promise((resolve, reject) => {
      this.promiseResolve = resolve;
      this.promiseReject = reject;
      setTimeout(() => {
        reject(new Error('timeout'));
      }, 10000);
    });
    this.verifyPromise();
    return promise;
  }

  verifyPromise() {
    if (!this.txSeqNo && this.txSeqNo != 0) {
      return;
    }

    if (!this.promiseResolve || !this.promiseReject) {
      return;
    }

    if (this.transactions[this.txSeqNo]) {
      if (this.transactions[this.txSeqNo] == 'Success') {
        this.promiseResolve();
      } else {
        this.promiseReject(this.transactions[this.txSeqNo]);
      }
    }
  }

  addTransaction(transaction, code) {
    if (this.transactions[transaction.seqNo]) return;
    this.transactions[transaction.seqNo] = code;
    this.verifyPromise();
  }

}

class db_Database {
  constructor(changeHandler, receivedMessage) {
    this.onChange = changeHandler;
    this.items = {};

    const compareItems = (a, b) => {
      if (a.seqNo < b.seqNo || a.seqNo === b.seqNo && a.operationIndex < b.operationIndex) {
        return -1;
      }

      if (a.seqNo > b.seqNo || a.seqNo === b.seqNo && a.operationIndex > b.operationIndex) {
        return 1;
      }

      return 0;
    };

    this.itemsIndex = new external_sorted_array_default.a([], compareItems);
    this.unverifiedTransactions = [];
    this.lastSeqNo = 0;
    this.init = false;
    this.dbKey = null;
    this.receivedMessage = receivedMessage; // Queue that ensures 'ApplyTransactions' executes one at a time

    this.applyTransactionsQueue = new Queue();
  }

  async applyTransactions(transactions) {
    for (let i = 0; i < transactions.length; i++) {
      const transaction = transactions[i];
      const seqNo = transaction.seqNo; // client must only apply transcations in sequence

      if (seqNo !== this.lastSeqNo + 1) {
        console.warn("Client attempted to apply transaction with seq no ".concat(seqNo, " when last seq no is ").concat(this.lastSeqNo));
        continue;
      }

      const transactionCode = await this.applyTransaction(this.dbKey, transaction);
      this.lastSeqNo = seqNo;

      for (let j = 0; j < this.unverifiedTransactions.length; j++) {
        if (!this.unverifiedTransactions[j] || seqNo < this.unverifiedTransactions[j].getStartSeqNo()) {
          continue;
        }

        this.unverifiedTransactions[j].addTransaction(transactions[i], transactionCode);
      }

      if (this.init && transactionCode === 'Success') {
        this.onChange(this.getItems());
      }
    }

    if (!this.init) {
      this.onChange(this.getItems());
    }
  }

  applyBundle(bundle, bundleSeqNo) {
    // client must only apply bundle when opening state
    if (this.lastSeqNo !== 0) {
      console.warn("Client attempted to apply bundle when last seq no is ".concat(this.lastSeqNo));
      return;
    }

    for (let i = 0; i < bundle.itemsIndex.length; i++) {
      const itemIndex = bundle.itemsIndex[i];
      const itemId = bundle.itemsIndex[i].itemId;
      const item = bundle.items[itemId];
      this.items[itemId] = item;
      this.itemsIndex.insert(itemIndex);
    }

    this.lastSeqNo = bundleSeqNo;
  }

  async applyTransaction(key, transaction) {
    const seqNo = transaction.seqNo;
    const command = transaction.command;

    switch (command) {
      case 'Insert':
        {
          const record = await Crypto.aesGcm.decryptJson(key, transaction.record);
          const itemId = record.id;
          const item = record.item;

          try {
            this.validateInsert(itemId);
          } catch (transactionCode) {
            return transactionCode;
          }

          return this.applyInsert(itemId, seqNo, item);
        }

      case 'Update':
        {
          const record = await Crypto.aesGcm.decryptJson(key, transaction.record);
          const itemId = record.id;
          const item = record.item;
          const __v = record.__v;

          try {
            this.validateUpdateOrDelete(itemId, __v);
          } catch (transactionCode) {
            return transactionCode;
          }

          return this.applyUpdate(itemId, item, __v);
        }

      case 'Delete':
        {
          const record = await Crypto.aesGcm.decryptJson(key, transaction.record);
          const itemId = record.id;
          const __v = record.__v;

          try {
            this.validateUpdateOrDelete(itemId, __v);
          } catch (transactionCode) {
            return transactionCode;
          }

          return this.applyDelete(itemId);
        }

      case 'BatchTransaction':
        {
          const batch = transaction.operations;
          const recordPromises = [];

          for (const operation of batch) {
            recordPromises.push(operation.record && Crypto.aesGcm.decryptJson(key, operation.record));
          }

          const records = await Promise.all(recordPromises);

          try {
            this.validateBatchTransaction(batch, records);
          } catch (transactionCode) {
            return transactionCode;
          }

          return this.applyBatchTransaction(seqNo, batch, records);
        }

      case 'Rollback':
        {
          // no-op
          return;
        }

      default:
        {
          console.warn("Unknown command: ".concat(command));
          return;
        }
    }
  }

  validateInsert(itemId) {
    if (this.items[itemId]) {
      throw new errors.ItemAlreadyExists();
    }
  }

  validateUpdateOrDelete(itemId, __v) {
    if (!this.items[itemId]) {
      throw new errors.ItemDoesNotExist();
    }

    const currentVersion = this.getItemVersionNumber(itemId);

    if (__v <= currentVersion) {
      throw new errors.ItemUpdateConflict();
    }
  }

  itemExists(itemId) {
    return objectHasOwnProperty(this.items, itemId);
  }

  applyInsert(itemId, seqNo, record, operationIndex) {
    const item = {
      seqNo
    };
    if (typeof operationIndex === 'number') item.operationIndex = operationIndex;
    this.items[itemId] = db_objectSpread({}, item, {
      record,
      __v: 0
    });
    this.itemsIndex.insert(db_objectSpread({}, item, {
      itemId
    }));
    return success;
  }

  applyUpdate(itemId, record, __v) {
    this.items[itemId].record = record;
    this.items[itemId].__v = __v;
    return success;
  }

  applyDelete(itemId) {
    this.itemsIndex.remove(this.items[itemId]);
    delete this.items[itemId];
    return success;
  }

  validateBatchTransaction(batch, records) {
    const uniqueItemIds = {};

    for (let i = 0; i < batch.length; i++) {
      const operation = batch[i];
      const itemId = records[i].id;
      const __v = records[i].__v;
      if (uniqueItemIds[itemId]) throw new errors.OperationsConflict();
      uniqueItemIds[itemId] = true;

      switch (operation.command) {
        case 'Insert':
          this.validateInsert(itemId);
          break;

        case 'Update':
        case 'Delete':
          this.validateUpdateOrDelete(itemId, __v);
          break;
      }
    }
  }

  applyBatchTransaction(seqNo, batch, records) {
    for (let i = 0; i < batch.length; i++) {
      const operation = batch[i];
      const itemId = records[i].id;
      const item = records[i].item;
      const __v = records[i].__v;

      switch (operation.command) {
        case 'Insert':
          this.applyInsert(itemId, seqNo, item, i);
          break;

        case 'Update':
          this.applyUpdate(itemId, item, __v);
          break;

        case 'Delete':
          this.applyDelete(itemId, __v);
          break;
      }
    }

    return success;
  }

  registerUnverifiedTransaction() {
    const unverifiedTransaction = new UnverifiedTransaction(this.lastSeqNo);
    const i = this.unverifiedTransactions.push(unverifiedTransaction);
    unverifiedTransaction.setIndex(i - 1);
    return unverifiedTransaction;
  }

  unregisterUnverifiedTransaction(pendingTransaction) {
    delete this.unverifiedTransactions[pendingTransaction.getIndex()];
  }

  getItems() {
    const result = [];

    for (let i = 0; i < this.itemsIndex.array.length; i++) {
      const itemId = this.itemsIndex.array[i].itemId;
      const record = this.items[itemId].record;
      result.push({
        itemId,
        item: record
      });
    }

    return result;
  }

  getItemVersionNumber(itemId) {
    return this.items[itemId].__v;
  }

}

const _openDatabase = async (dbNameHash, changeHandler, newDatabaseParams) => {
  try {
    const database = src_ws.state.databases[dbNameHash];
    let receivedMessage;
    let timeout;
    const firstMessageFromWebSocket = new Promise((resolve, reject) => {
      receivedMessage = resolve;
      timeout = setTimeout(() => reject(new Error('timeout')), 20000);
    });

    if (!database) {
      src_ws.state.databases[dbNameHash] = new db_Database(changeHandler, receivedMessage);
    } else {
      // safe to replace -- enables idempotent calls to openDatabase
      database.onChange = changeHandler; // if 1 call succeeds, all idempotent calls succeed

      const currentReceivedMessage = database.receivedMessage;

      database.receivedMessage = () => {
        currentReceivedMessage();
        receivedMessage();
      }; // database is already open, can return successfully


      if (database.init) {
        changeHandler(database.getItems());
        database.receivedMessage();
        return;
      }
    }

    const action = 'OpenDatabase';
    const params = {
      dbNameHash,
      newDatabaseParams
    };

    try {
      await src_ws.request(action, params);
      await firstMessageFromWebSocket;
    } catch (e) {
      clearTimeout(timeout);

      if (e.response && e.response.data) {
        const data = e.response.data;

        if (data === 'Database already creating') {
          throw new errors.DatabaseAlreadyOpening();
        }

        switch (data.name) {
          case 'SubscriptionPlanNotSet':
            throw new errors.SubscriptionPlanNotSet();

          case 'SubscriptionNotFound':
            throw new errors.SubscriptionNotFound();

          case 'SubscribedToIncorrectPlan':
            throw new errors.SubscribedToIncorrectPlan();

          case 'SubscriptionInactive':
            throw new errors.SubscriptionInactive(data.subscriptionStatus);

          case 'TrialExpired':
            throw new errors.TrialExpired();
        }
      }

      throw e;
    }
  } catch (e) {
    db_parseGenericErrors(e);

    throw e;
  }
};

const _createDatabase = async dbName => {
  const dbId = v4_default()();
  const dbKey = await Crypto.aesGcm.generateKey();
  const dbKeyString = await Crypto.aesGcm.getKeyStringFromKey(dbKey);
  const [encryptedDbKey, encryptedDbName] = await Promise.all([Crypto.aesGcm.encryptString(src_ws.keys.encryptionKey, dbKeyString), Crypto.aesGcm.encryptString(dbKey, dbName)]);
  const newDatabaseParams = {
    dbId,
    encryptedDbKey,
    encryptedDbName
  };
  return newDatabaseParams;
};

const _validateDbInput = params => {
  if (typeof params !== 'object') throw new errors.ParamsMustBeObject();
  if (!objectHasOwnProperty(params, 'databaseName')) throw new errors.DatabaseNameMissing();
  const dbName = params.databaseName;
  if (typeof dbName !== 'string') throw new errors.DatabaseNameMustBeString();
  if (dbName.length === 0) throw new errors.DatabaseNameCannotBeBlank();
  if (dbName.length > MAX_DB_NAME_CHAR_LENGTH) throw new errors.DatabaseNameTooLong(MAX_DB_NAME_CHAR_LENGTH);
  if (src_ws.reconnecting) throw new errors.Reconnecting();
  if (!src_ws.keys.init) throw new errors.UserNotSignedIn();
};

const openDatabase = async params => {
  try {
    _validateDbInput(params);

    if (!objectHasOwnProperty(params, 'changeHandler')) throw new errors.ChangeHandlerMissing();
    const {
      databaseName,
      changeHandler
    } = params;
    if (typeof changeHandler !== 'function') throw new errors.ChangeHandlerMustBeFunction();
    const dbNameHash = src_ws.state.dbNameToHash[databaseName] || (await Crypto.hmac.signString(src_ws.keys.hmacKey, databaseName));
    src_ws.state.dbNameToHash[databaseName] = dbNameHash; // eslint-disable-line require-atomic-updates

    const newDatabaseParams = await _createDatabase(databaseName);
    await _openDatabase(dbNameHash, changeHandler, newDatabaseParams);
  } catch (e) {
    switch (e.name) {
      case 'ParamsMustBeObject':
      case 'DatabaseAlreadyOpening':
      case 'DatabaseNameMustBeString':
      case 'DatabaseNameMissing':
      case 'DatabaseNameCannotBeBlank':
      case 'DatabaseNameTooLong':
      case 'ChangeHandlerMissing':
      case 'ChangeHandlerMustBeFunction':
      case 'UserNotSignedIn':
      case 'UserNotFound':
      case 'SubscriptionPlanNotSet':
      case 'SubscriptionNotFound':
      case 'SubscribedToIncorrectPlan':
      case 'SubscriptionInactive':
      case 'TrialExpired':
      case 'TooManyRequests':
      case 'ServiceUnavailable':
        throw e;

      default:
        throw new errors.UnknownServiceUnavailable(e);
    }
  }
};

const getOpenDb = dbName => {
  const dbNameHash = src_ws.state.dbNameToHash[dbName];
  const database = src_ws.state.databases[dbNameHash];
  if (!dbNameHash || !database || !database.init) throw new errors.DatabaseNotOpen();
  return database;
};

const insertItem = async params => {
  try {
    _validateDbInput(params);

    const database = getOpenDb(params.databaseName);
    const action = 'Insert';
    const insertParams = await _buildInsertParams(database, params);
    await postTransaction(database, action, insertParams);
  } catch (e) {
    switch (e.name) {
      case 'ParamsMustBeObject':
      case 'DatabaseNotOpen':
      case 'DatabaseNameMissing':
      case 'DatabaseNameMustBeString':
      case 'DatabaseNameCannotBeBlank':
      case 'DatabaseNameTooLong':
      case 'ItemIdMustBeString':
      case 'ItemIdCannotBeBlank':
      case 'ItemIdTooLong':
      case 'ItemMissing':
      case 'ItemInvalid':
      case 'ItemTooLarge':
      case 'ItemAlreadyExists':
      case 'UserNotSignedIn':
      case 'UserNotFound':
      case 'TooManyRequests':
      case 'ServiceUnavailable':
        throw e;

      default:
        throw new errors.UnknownServiceUnavailable(e);
    }
  }
};

const _buildInsertParams = async (database, params) => {
  if (!objectHasOwnProperty(params, 'item')) throw new errors.ItemMissing();
  const {
    item,
    itemId
  } = params;

  if (objectHasOwnProperty(params, 'itemId')) {
    if (typeof itemId !== 'string') throw new errors.ItemIdMustBeString();
    if (itemId.length === 0) throw new errors.ItemIdCannotBeBlank();
    if (itemId.length > MAX_ITEM_ID_CHAR_LENGTH) throw new errors.ItemIdTooLong(MAX_ITEM_ID_CHAR_LENGTH);
  }

  const itemString = JSON.stringify(item);
  if (!itemString) throw new errors.ItemInvalid();
  if (byteSizeOfString(itemString) > MAX_ITEM_BYTES) throw new errors.ItemTooLarge(MAX_ITEM_KB);
  const id = itemId || v4_default()();
  const itemKey = await Crypto.hmac.signString(src_ws.keys.hmacKey, id);
  const itemRecord = {
    id,
    item
  };
  const encryptedItem = await Crypto.aesGcm.encryptJson(database.dbKey, itemRecord);
  return {
    itemKey,
    encryptedItem
  };
};

const updateItem = async params => {
  try {
    _validateDbInput(params);

    const database = getOpenDb(params.databaseName);
    const action = 'Update';
    const updateParams = await _buildUpdateParams(database, params);
    await postTransaction(database, action, updateParams);
  } catch (e) {
    switch (e.name) {
      case 'ParamsMustBeObject':
      case 'DatabaseNotOpen':
      case 'DatabaseNameMissing':
      case 'DatabaseNameMustBeString':
      case 'DatabaseNameCannotBeBlank':
      case 'DatabaseNameTooLong':
      case 'ItemIdMissing':
      case 'ItemIdMustBeString':
      case 'ItemIdCannotBeBlank':
      case 'ItemIdTooLong':
      case 'ItemMissing':
      case 'ItemInvalid':
      case 'ItemTooLarge':
      case 'ItemDoesNotExist':
      case 'ItemUpdateConflict':
      case 'UserNotSignedIn':
      case 'UserNotFound':
      case 'TooManyRequests':
      case 'ServiceUnavailable':
        throw e;

      default:
        throw new errors.UnknownServiceUnavailable();
    }
  }
};

const _buildUpdateParams = async (database, params) => {
  if (!objectHasOwnProperty(params, 'item')) throw new errors.ItemMissing();
  if (!objectHasOwnProperty(params, 'itemId')) throw new errors.ItemIdMissing();
  const {
    item,
    itemId
  } = params;
  if (typeof itemId !== 'string') throw new errors.ItemIdMustBeString();
  if (itemId.length === 0) throw new errors.ItemIdCannotBeBlank();
  if (itemId.length > MAX_ITEM_ID_CHAR_LENGTH) throw new errors.ItemIdTooLong(MAX_ITEM_ID_CHAR_LENGTH);
  if (!database.itemExists(itemId)) throw new errors.ItemDoesNotExist();
  const itemString = JSON.stringify(item);
  if (!itemString) throw new errors.ItemInvalid();
  if (byteSizeOfString(itemString) > MAX_ITEM_BYTES) throw new errors.ItemTooLarge(MAX_ITEM_KB);
  const itemKey = await Crypto.hmac.signString(src_ws.keys.hmacKey, itemId);
  const currentVersion = database.getItemVersionNumber(itemId);
  const itemRecord = {
    id: itemId,
    item,
    __v: currentVersion + 1
  };
  const encryptedItem = await Crypto.aesGcm.encryptJson(database.dbKey, itemRecord);
  return {
    itemKey,
    encryptedItem
  };
};

const deleteItem = async params => {
  try {
    _validateDbInput(params);

    const database = getOpenDb(params.databaseName);
    const action = 'Delete';
    const deleteParams = await _buildDeleteParams(database, params);
    await postTransaction(database, action, deleteParams);
  } catch (e) {
    switch (e.name) {
      case 'ParamsMustBeObject':
      case 'DatabaseNotOpen':
      case 'DatabaseNameMissing':
      case 'DatabaseNameMustBeString':
      case 'DatabaseNameCannotBeBlank':
      case 'DatabaseNameTooLong':
      case 'ItemIdMissing':
      case 'ItemIdMustBeString':
      case 'ItemIdCannotBeBlank':
      case 'ItemIdTooLong':
      case 'ItemDoesNotExist':
      case 'ItemUpdateConflict':
      case 'UserNotSignedIn':
      case 'UserNotFound':
      case 'TooManyRequests':
      case 'ServiceUnavailable':
        throw e;

      default:
        throw new errors.UnknownServiceUnavailable(e);
    }
  }
};

const _buildDeleteParams = async (database, params) => {
  if (!objectHasOwnProperty(params, 'itemId')) throw new errors.ItemIdMissing();
  const {
    itemId
  } = params;
  if (typeof itemId !== 'string') throw new errors.ItemIdMustBeString();
  if (itemId.length === 0) throw new errors.ItemIdCannotBeBlank();
  if (itemId.length > MAX_ITEM_ID_CHAR_LENGTH) throw new errors.ItemIdTooLong(MAX_ITEM_ID_CHAR_LENGTH);
  if (!database.itemExists(itemId)) throw new errors.ItemDoesNotExist();
  const itemKey = await Crypto.hmac.signString(src_ws.keys.hmacKey, itemId);
  const currentVersion = database.getItemVersionNumber(itemId);
  const itemRecord = {
    id: itemId,
    __v: currentVersion + 1
  };
  const encryptedItem = await Crypto.aesGcm.encryptJson(database.dbKey, itemRecord);
  return {
    itemKey,
    encryptedItem
  };
};

const putTransaction = async params => {
  try {
    _validateDbInput(params);

    if (!objectHasOwnProperty(params, 'operations')) throw new errors.OperationsMissing();
    const {
      databaseName,
      operations
    } = params;
    if (!Array.isArray(operations)) throw new errors.OperationsMustBeArray();
    const database = getOpenDb(databaseName);
    const action = 'BatchTransaction';
    const operationParamsPromises = await Promise.all(operations.map(operation => {
      const command = operation.command;

      switch (command) {
        case 'Insert':
          {
            return _buildInsertParams(database, operation);
          }

        case 'Update':
          {
            return _buildUpdateParams(database, operation);
          }

        case 'Delete':
          {
            return _buildDeleteParams(database, operation);
          }

        default:
          throw new errors.CommandNotRecognized(command);
      }
    }));
    const operationParamsPromiseResults = await Promise.all(operationParamsPromises);
    const operationParams = {
      operations: operations.map((operation, i) => db_objectSpread({
        command: operation.command
      }, operationParamsPromiseResults[i]))
    };

    try {
      await postTransaction(database, action, operationParams);
    } catch (e) {
      if (e.response && e.response.data.error === 'OperationsExceedLimit') {
        throw new errors.OperationsExceedLimit(e.response.data.limit);
      }

      throw e;
    }
  } catch (e) {
    switch (e.name) {
      case 'ParamsMustBeObject':
      case 'DatabaseNotOpen':
      case 'DatabaseNameMissing':
      case 'DatabaseNameMustBeString':
      case 'DatabaseNameCannotBeBlank':
      case 'DatabaseNameTooLong':
      case 'OperationsMissing':
      case 'OperationsMustBeArray':
      case 'OperationsConflict':
      case 'OperationsExceedLimit':
      case 'CommandNotRecognized':
      case 'ItemIdMissing':
      case 'ItemIdMustBeString':
      case 'ItemIdCannotBeBlank':
      case 'ItemIdTooLong':
      case 'ItemMissing':
      case 'ItemInvalid':
      case 'ItemTooLarge':
      case 'ItemAlreadyExists':
      case 'ItemDoesNotExist':
      case 'ItemUpdateConflict':
      case 'UserNotSignedIn':
      case 'UserNotFound':
      case 'TooManyRequests':
      case 'ServiceUnavailable':
        throw e;

      default:
        throw new errors.UnknownServiceUnavailable(e);
    }
  }
};

const postTransaction = async (database, action, params) => {
  try {
    const pendingTx = database.registerUnverifiedTransaction();

    const paramsWithDbData = db_objectSpread({}, params, {
      dbId: database.dbId,
      dbNameHash: src_ws.state.dbIdToHash[database.dbId]
    });

    const response = await src_ws.request(action, paramsWithDbData);
    const seqNo = response.data.sequenceNo;
    await pendingTx.getResult(seqNo);
    database.unregisterUnverifiedTransaction(pendingTx);
    return seqNo;
  } catch (e) {
    db_parseGenericErrors(e);

    throw e;
  }
};

const _buildDatabaseResult = async db => {
  const dbKeyString = await Crypto.aesGcm.decryptString(src_ws.keys.encryptionKey, db.encryptedDbKey);
  const dbKey = await Crypto.aesGcm.getKeyFromKeyString(dbKeyString);
  const databaseName = await Crypto.aesGcm.decryptString(dbKey, db.databaseName);
  return {
    databaseName
  };
};

const getDatabases = async () => {
  try {
    if (!src_ws.keys.init) throw new errors.UserNotSignedIn();

    try {
      const databases = [];
      let action = 'GetDatabases';
      let databasesResponse = await src_ws.request(action);
      let databaseResults = await Promise.all(databasesResponse.data.databases.map(db => _buildDatabaseResult(db)));
      databases.push(...databaseResults);

      while (databasesResponse.data.nextPageToken) {
        const params = {
          nextPageToken: databasesResponse.data.nextPageToken
        };
        databasesResponse = await src_ws.request(action, params);
        databaseResults = await Promise.all(databasesResponse.data.databases.map(db => _buildDatabaseResult(db)));
        databases.push(...databaseResults);
      }

      return {
        databases
      };
    } catch (e) {
      db_parseGenericErrors(e);

      throw e;
    }
  } catch (e) {
    switch (e.name) {
      case 'UserNotSignedIn':
      case 'ServiceUnavailable':
        throw e;

      default:
        throw new errors.ServiceUnavailable();
    }
  }
};

/* harmony default export */ var src_db = ({
  openDatabase,
  getDatabases,
  insertItem,
  updateItem,
  deleteItem,
  putTransaction
});
// CONCATENATED MODULE: ./src/payments.js






const payments_parseGenericErrors = e => {
  if (e.response) {
    if (e.response.status === statusCodes['Internal Server Error']) {
      throw new errors.InternalServerError();
    } else if (e.response.status === statusCodes['Gateway Timeout']) {
      throw new errors.Timeout();
    }
  } else if (e.message && e.message.includes('timeout')) {
    throw new errors.Timeout();
  }
};

const _validatePurchaseOrUpdate = params => {
  if (src_ws.reconnecting) throw new errors.Reconnecting();
  if (!src_ws.keys.init) throw new errors.UserNotSignedIn();
  const stripeData = src_ws.userData.stripeData;
  if (!stripeData.stripeAccountId) throw new errors.StripeAccountNotConnected();
  if (stripeData.paymentsMode === 'disabled') throw new errors.PaymentsDisabled();
  if (!objectHasOwnProperty(window, 'Stripe')) throw new errors.StripeJsLibraryMissing();
  if (typeof params !== 'object') throw new errors.ParamsMustBeObject();
  if (!objectHasOwnProperty(params, 'successUrl')) throw new errors.SuccessUrlMissing();
  if (typeof params.successUrl !== 'string') throw new errors.SuccessUrlMustBeString();
  const successUrlProtocol = getProtocolFromEndpoint(params.successUrl);

  if (successUrlProtocol !== 'http' && successUrlProtocol !== 'https') {
    const invalidProtocol = true;
    throw new errors.SuccessUrlInvalid(invalidProtocol);
  }

  if (!objectHasOwnProperty(params, 'cancelUrl')) throw new errors.CancelUrlMissing();
  if (typeof params.cancelUrl !== 'string') throw new errors.CancelUrlMustBeString();
  const cancelUrlProtocol = getProtocolFromEndpoint(params.cancelUrl);

  if (cancelUrlProtocol !== 'http' && cancelUrlProtocol !== 'https') {
    const invalidProtocol = true;
    throw new errors.CancelUrlInvalid(invalidProtocol);
  }
};

const purchaseSubscription = async params => {
  try {
    const stripeData = src_ws.userData.stripeData;

    if (stripeData.subscriptionStatus && stripeData.subscriptionStatus !== 'canceled') {
      throw new errors.SubscriptionPlanAlreadyPurchased();
    }

    _validatePurchaseOrUpdate(params);

    try {
      const action = 'PurchaseSubscription';
      const sessionIdResponse = await src_ws.request(action, params);
      const stripeSessionId = sessionIdResponse.data;
      const stripePk = src_config.getStripePublishableKey(stripeData.paymentsMode === 'prod');
      const result = await window.Stripe(stripePk, {
        stripeAccount: stripeData.stripeAccountId
      }).redirectToCheckout({
        sessionId: stripeSessionId
      });
      if (result.error) throw result.error;
    } catch (e) {
      payments_parseGenericErrors(e);

      if (e.response) {
        if (e.response.data === 'SubscriptionPlanNotSet') {
          throw new errors.SubscriptionPlanNotSet();
        } else if (e.response.data === 'SubscriptionPlanAlreadyPurchased') {
          throw new errors.SubscriptionPlanAlreadyPurchased();
        } else if (e.response.data === 'SuccessUrlInvalid') {
          throw new errors.SuccessUrlInvalid();
        } else if (e.response.data === 'CancelUrlInvalid') {
          throw new errors.CancelUrlInvalid();
        } else if (e.response.data && e.response.data.name === 'StripeError') {
          throw new errors.StripeError(e.response.data);
        }
      }

      throw e;
    }
  } catch (e) {
    switch (e.name) {
      case 'ParamsMustBeObject':
      case 'SuccessUrlMissing':
      case 'SuccessUrlMustBeString':
      case 'SuccessUrlInvalid':
      case 'CancelUrlMissing':
      case 'CancelUrlMustBeString':
      case 'CancelUrlInvalid':
      case 'StripeError':
      case 'StripeJsLibraryMissing':
      case 'SubscriptionPlanNotSet':
      case 'SubscriptionPlanAlreadyPurchased':
      case 'StripeAccountNotConnected':
      case 'PaymentsDisabled':
      case 'UserNotSignedIn':
      case 'TooManyRequests':
      case 'ServiceUnavailable':
        throw e;

      default:
        throw new errors.UnknownServiceUnavailable(e);
    }
  }
};

const _validateModifySubscriptionConditions = () => {
  if (src_ws.reconnecting) throw new errors.Reconnecting();
  if (!src_ws.keys.init) throw new errors.UserNotSignedIn();
  const stripeData = src_ws.userData.stripeData;
  if (!stripeData.stripeAccountId) throw new errors.StripeAccountNotConnected();
  if (stripeData.paymentsMode === 'disabled') throw new errors.PaymentsDisabled();
  if (stripeData.subscriptionStatus === 'canceled') throw new errors.SubscriptionAlreadyCanceled();
};

const cancelSubscription = async () => {
  try {
    _validateModifySubscriptionConditions();

    try {
      const action = 'CancelSubscription';
      const cancelResponse = await src_ws.request(action);
      const cancelSubscriptionAt = cancelResponse.data;
      src_ws.userData.stripeData.cancelAt = cancelSubscriptionAt;
      return {
        cancelSubscriptionAt
      };
    } catch (e) {
      payments_parseGenericErrors(e);

      if (e.response && e.response.data === 'SubscriptionPlanNotSet') {
        throw new errors.SubscriptionPlanNotSet();
      }

      throw e;
    }
  } catch (e) {
    switch (e.name) {
      case 'SubscriptionPlanNotSet':
      case 'StripeAccountNotConnected':
      case 'PaymentsDisabled':
      case 'SubscriptionAlreadyCanceled':
      case 'UserNotSignedIn':
      case 'TooManyRequests':
      case 'ServiceUnavailable':
        throw e;

      default:
        throw new errors.UnknownServiceUnavailable(e);
    }
  }
};

const resumeSubscription = async () => {
  try {
    _validateModifySubscriptionConditions();

    try {
      const action = 'ResumeSubscription';
      await src_ws.request(action);
      delete src_ws.userData.stripeData.cancelAt;
    } catch (e) {
      payments_parseGenericErrors(e);

      if (e.response && e.response.data === 'SubscriptionPlanNotSet') {
        throw new errors.SubscriptionPlanNotSet();
      }

      throw e;
    }
  } catch (e) {
    switch (e.name) {
      case 'SubscriptionPlanNotSet':
      case 'StripeAccountNotConnected':
      case 'PaymentsDisabled':
      case 'SubscriptionAlreadyCanceled':
      case 'UserNotSignedIn':
      case 'TooManyRequests':
      case 'ServiceUnavailable':
        throw e;

      default:
        throw new errors.UnknownServiceUnavailable(e);
    }
  }
};

const updatePaymentMethod = async params => {
  try {
    _validatePurchaseOrUpdate(params);

    const stripeData = src_ws.userData.stripeData;
    if (!stripeData.subscriptionStatus) throw new errors.SubscriptionNotPurchased();

    try {
      const action = 'UpdatePaymentMethod';
      const sessionIdResponse = await src_ws.request(action, params);
      const stripeSessionId = sessionIdResponse.data;
      const stripePk = src_config.getStripePublishableKey(stripeData.paymentsMode === 'prod');
      const result = await window.Stripe(stripePk, {
        stripeAccount: stripeData.stripeAccountId
      }).redirectToCheckout({
        sessionId: stripeSessionId
      });
      if (result.error) throw result.error;
    } catch (e) {
      payments_parseGenericErrors(e);

      if (e.response) {
        if (e.response.data === 'SuccessUrlInvalid') {
          throw new errors.SuccessUrlInvalid();
        } else if (e.response.data === 'CancelUrlInvalid') {
          throw new errors.CancelUrlInvalid();
        }
      }

      throw e;
    }
  } catch (e) {
    switch (e.name) {
      case 'ParamsMustBeObject':
      case 'SuccessUrlMissing':
      case 'SuccessUrlMustBeString':
      case 'SuccessUrlInvalid':
      case 'CancelUrlMissing':
      case 'CancelUrlMustBeString':
      case 'CancelUrlInvalid':
      case 'StripeJsLibraryMissing':
      case 'SubscriptionNotPurchased':
      case 'StripeAccountNotConnected':
      case 'PaymentsDisabled':
      case 'UserNotSignedIn':
      case 'TooManyRequests':
      case 'ServiceUnavailable':
        throw e;

      default:
        throw new errors.UnknownServiceUnavailable(e);
    }
  }
};

/* harmony default export */ var src_payments = ({
  purchaseSubscription,
  cancelSubscription,
  resumeSubscription,
  updatePaymentMethod
});
// CONCATENATED MODULE: ./src/index.js



/* harmony default export */ var src = __webpack_exports__["default"] = ({
  init: src_auth.init,
  signUp: src_auth.signUp,
  signIn: src_auth.signIn,
  signOut: src_auth.signOut,
  updateUser: src_auth.updateUser,
  deleteUser: src_auth.deleteUser,
  forgotPassword: src_auth.forgotPassword,
  openDatabase: src_db.openDatabase,
  getDatabases: src_db.getDatabases,
  insertItem: src_db.insertItem,
  updateItem: src_db.updateItem,
  deleteItem: src_db.deleteItem,
  putTransaction: src_db.putTransaction,
  purchaseSubscription: src_payments.purchaseSubscription,
  cancelSubscription: src_payments.cancelSubscription,
  resumeSubscription: src_payments.resumeSubscription,
  updatePaymentMethod: src_payments.updatePaymentMethod
});

/***/ })
/******/ ])["default"]));
//# sourceMappingURL=userbase.cjs.js.map